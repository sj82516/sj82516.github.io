<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Javascript on Yuanchieh&#39;s Blog</title>
		<link>https://yuanchieh.page/categories/javascript/</link>
		<description>Recent content in Javascript on yuanchieh.page</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Sun, 07 Jun 2020 08:21:40 +0000</lastBuildDate>
		
		<atom:link href="https://yuanchieh.page/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>gRPC 介紹與 Nodejs 實作分享</title>
			<link>https://yuanchieh.page/posts/2020-06-07_grpc-%E4%BB%8B%E7%B4%B9%E8%88%87-js-%E5%AF%A6%E4%BD%9C%E5%88%86%E4%BA%AB/</link>
			<pubDate>Sun, 07 Jun 2020 08:21:40 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2020-06-07_grpc-%E4%BB%8B%E7%B4%B9%E8%88%87-js-%E5%AF%A6%E4%BD%9C%E5%88%86%E4%BA%AB/</guid>
			<description>
				
				gRPC 是一種由 Google 推出的 Client / Server 通訊協定，有別於一般常見的 HTTP &#43; JSON 的 API Endpoint，gRPC 帶來了協作與效率上改進
				
			</description>
		</item>
		<item>
			<title>JS Proxy / Reflect 實戰 - 實作 API 自動 retry 機制</title>
			<link>https://yuanchieh.page/posts/2020-05-27_js-proxy-%E8%88%87-reflect-%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 27 May 2020 08:21:40 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2020-05-27_js-proxy-%E8%88%87-reflect-%E4%BD%BF%E7%94%A8/</guid>
			<description>
				
				介紹 ES6 推出的 Proxy 與 Reflect，並分享使用場景 - console log 於正式環境複寫功能與API 自動 retry 機制
				
			</description>
		</item>
		<item>
			<title>《How Javascript Works》讀後整理 上</title>
			<link>https://yuanchieh.page/posts/2019-09-30_how-javascript-works-review-%E4%B8%8A/</link>
			<pubDate>Wed, 02 Oct 2019 00:21:40 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2019-09-30_how-javascript-works-review-%E4%B8%8A/</guid>
			<description>
				
				Douglas 思考著 The Next Language 下一代的程式語言該具備的樣貌，延伸前作 《JavaScript- The Good Parts》，Douglas 頗析 JS的每一個環節，先解構 JS現有的存在，再重構出一門他覺得最接近下個世代程式語言的雛形
				
			</description>
		</item>
		<item>
			<title>V8 內的排序演算法 — Timsort</title>
			<link>https://yuanchieh.page/posts/2019-08-09_v8-%E5%85%A7%E7%9A%84%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95-timsort/</link>
			<pubDate>Fri, 09 Aug 2019 05:41:03 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2019-08-09_v8-%E5%85%A7%E7%9A%84%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95-timsort/</guid>
			<description>
				
				Timsort 廣泛應用在 Python / Android，現在 V8 JS Engine 也改用 Timsort 當作預設的排序法，此篇分享 Timsort實作的細節 
				
			</description>
		</item>
		<item>
			<title>V8 Zero Stack Async Stack Trace 研究</title>
			<link>https://yuanchieh.page/posts/2019-01-01_v8-zero-stack-async-stack-trace/</link>
			<pubDate>Tue, 01 Jan 2019 10:27:29 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2019-01-01_v8-zero-stack-async-stack-trace/</guid>
			<description>
				
				這份是在 2018/11/20 由 V8 Team 釋出的文件，主要描述用一種新的Async 錯誤追蹤機制，此新機制僅適用於 async await
				
			</description>
		</item>
		<item>
			<title>愛用 async / await 而非 promise!</title>
			<link>https://yuanchieh.page/posts/2018-12-28_async-await-instead-of-promise/</link>
			<pubDate>Fri, 28 Dec 2018 01:39:30 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-12-28_async-await-instead-of-promise/</guid>
			<description>
				
				近期看不到少關於 async / await 的好文章，這裡特別摘錄兩篇總結
				
			</description>
		</item>
		<item>
			<title>V8 如何優化 async / await</title>
			<link>https://yuanchieh.page/posts/2018-12-25_v8-async-await/</link>
			<pubDate>Tue, 25 Dec 2018 13:06:04 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-12-25_v8-async-await/</guid>
			<description>
				
				JS 基於事件驅動，大量的 Promise 充斥在應用程式中，其後在 ES2017 加入了 async/ await 語法糖後，讓非同步代碼更加簡潔與直覺
				
			</description>
		</item>
		<item>
			<title>Express 與 Koa 如何處理錯誤</title>
			<link>https://yuanchieh.page/posts/2018-08-27_express-koa-error-handling-comapre/</link>
			<pubDate>Mon, 27 Aug 2018 07:20:36 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-08-27_express-koa-error-handling-comapre/</guid>
			<description>
				
				以前只注重把功能寫出來而已，慢慢地開始維護後發現一開始的系統規劃很重要，包含基本的 Loggin / Debugging / Error Handling，以及是否能將每個物件函式乾淨拆分避免過多副作用無法編寫測試(詳見另一篇網誌)
				
			</description>
		</item>
		<item>
			<title>使用 Jest 做API 單元測試的範例與細節</title>
			<link>https://yuanchieh.page/posts/2018-08-06_jest-api/</link>
			<pubDate>Mon, 06 Aug 2018 10:42:40 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-08-06_jest-api/</guid>
			<description>
				
				nojest 之前寫測試因為沒有注意細節，導致非常難編寫單元測試；改以 End-to-End測試，直接用docker 開DB輸入假資料，接著執行 Server App 對API一隻一隻測試。
				
			</description>
		</item>
		<item>
			<title>為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題</title>
			<link>https://yuanchieh.page/posts/2018-07-16_nodejs-event-loop-to-fix-graphql-n-1/</link>
			<pubDate>Mon, 16 Jul 2018 12:35:50 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-07-16_nodejs-event-loop-to-fix-graphql-n-1/</guid>
			<description>
				
				Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。
				
			</description>
		</item>
		<item>
			<title>Jonathan Martin: Async patterns to scale your multicore JavaScript elegantly 總結與試驗</title>
			<link>https://yuanchieh.page/posts/2018-06-27_async-patterns-to-scale-your-multicore-javascript-elegantly/</link>
			<pubDate>Wed, 27 Jun 2018 04:03:50 +0000</pubDate>
			
			<guid>https://yuanchieh.page/posts/2018-06-27_async-patterns-to-scale-your-multicore-javascript-elegantly/</guid>
			<description>
				
				利用Async Pattern 提升JS在多核心上的執行速度
				
			</description>
		</item>
		
	</channel>
</rss>
