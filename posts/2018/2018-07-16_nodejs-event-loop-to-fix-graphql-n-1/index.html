<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.81.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。"><meta property="og:title" content="為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題" />
<meta property="og:description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2018/2018-07-16_nodejs-event-loop-to-fix-graphql-n-1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-16T12:35:50&#43;00:00" />
<meta property="article:modified_time" content="2018-07-16T12:35:50&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題"/>
<meta name="twitter:description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題 | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">16</span>
				<span class="rest">Jul 2018</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題</h1>
		</div>
	</div>
	<div class="markdown">
		<p>Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。</p>
<pre><code>// copy from nodejs 官網   ┌───────────────────────────┐┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │     pending callbacks     ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       │   (internal use)│  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤  connections, ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │           check           ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘
</code></pre><p>簡而言之，Event Loop有許多不同的階段(phase)，每個phase 是個陣列，當完成非同步操作後，會對應將 callback task push到 phase中；<br>
Nodejs會不斷的輪詢 Event Loop並<code>同步執行callback task</code>，直到 Event Loop上都沒有 task且 Main thread也都執行完成，就會退出。</p>
<p>Nodejs一些非同步操作對應的 phase如下<br>
1.<code>setTimeout</code> 屬於 timers <br>
2. <code>pending callbacks</code>主要處理系統錯誤 callback<br>
3. poll 階段則是向系統取得 IO事件<br>
4.<code>setImmediate</code> 屬於 check<br>
5.<code>關閉事件如 socket.on(‘close’, …)</code> 則屬於 close</p>
<p><code>process.nextTick</code> 是在每個phase結束前執行， <code>Promise</code> 屬於 microtask，同樣執行於每個phase結束之前，且在 process.nextTick之前；<br>
所以要小心，不能要遞迴呼叫process.nextTick，會導致整個Event Loop卡住，因為每個process.nextTick都會在phase結束前執行。</p>
<p>以上大致介紹，實際運作複雜許多，附註參考資料：<br>
1. <a href="https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html">https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html</a><br>
2. <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a><br>
3. <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a><br>
4. 在瀏覽器中狀況跟Nodejs執行環境不太相同 <a href="https://github.com/kaola-fed/blog/issues/234#code-analysis-b-a">https://github.com/kaola-fed/blog/issues/234#code-analysis-b-a</a></p>
<p>但我看這個有什麼用? 只要我知道怎麼寫非同步程式碼，了解底層 Event Loop執行順序有什麼意義嗎?</p>
<p>雖然說學習不該帶有太強烈的功利性，追根究底本身就是個樂趣，但這個問題著實困擾我頗久，在這兩天看到了 <code>dataloader</code> 驚為天人的 Library，以下正文開始。</p>
<h2 id="dataloader的用途">dataloader的用途</h2>
<p>dataloader主要用於解決Graphql的N+1問題，稍微簡單介紹一下<br>
Graphql是 FB提出的技術，用來當作新一代的前後端API交互介面，主要是將搜尋的能力交還給前端控制，後端就被動配合；<br>
改善以往 RESTful API在 GET上麻煩的地方，以下為示範</p>
<p>假設有 User / Post / Comment，<br>
User 1 &lt;-&gt; m Post，User可以創建多個Post<br>
User 1 &lt;-&gt; n Comment m &lt;-&gt; 1 Post，User可以在Post下發布 Comment</p>
<p>假設今天我們要顯示某用戶的所有貼文，以REST來講可能是<br>
/user/:userId/post<br>
如果要某用戶下所有貼文帶評論<br>
/user/:userId/post/comment<br>
如果是某用戶某貼文的所有評論<br>
/user/:userId/post/:postId/comment<br>
&hellip;&hellip;</p>
<p>所以在查詢上，前端多一個需求後端就要多一隻API，有點麻煩<br>
如果要省著用同一個API外加query來判斷，就變成資料層或邏輯層一樣要處理</p>
<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br>
而Graphql 則漂亮很多，前端定義好需要的資料格式，後端就會對照回傳(套件輔助)</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-graphql" data-lang="graphql">{    
   User {   
      name,  
      id,  
      Post {  
         title,  
         Comment {  
             content,  
             User <span style="color:#66d9ef">......</span><span style="color:#960050;background-color:#1e0010">.</span>  
}
</code></pre></td></tr></table>
</div>
</div><p>不論是要取得 User，User -&gt; Post， User -&gt; Post -&gt; Comment無限遞迴，都是非常簡單的一件事</p>
<p>後端則是對應好資料擷取，Graphql在後端會過濾把前端需要的欄位回傳，大幅降低網路 payload，非常的簡潔有力。</p>
<p>如果是有大量查詢的應用程式，或是有跨裝置應用，可以考慮導入 Graphql，現在來說方案都已經非常成熟了。</p>
<h3 id="graphql-n1問題">Graphql N+1問題</h3>
<p>但是在讀取巢狀資料的過程中，Graphql會發生N+1問題，例如取得所有用戶下的所有文章<code>{User{Post}}</code> ，這時候因為架構設計的關係，Graphql會先讀取所有的User，接著再針對個別User去讀取Post；<br>
所以資料庫讀取會變成 1 次讀取全部 User + N次個別User讀取Post，例如</p>
<pre><code>SELECT \* FROM User; --&gt; 回傳了 [1,2,3,4]  
SELECT \* FROM Post WHERE user_id = 1;  
SELECT \* FROM Post WHERE user_id = 2;  
....

\---&gt; 較為理想情況  
SELECT \* FROM User; --&gt; 回傳了 [1,2,3,4]  
SELECT \* FROM Post WHERE user_id in (1,2,3,4);

\---&gt; 最理想  
SELECT \* FROM User LEFT JOIN Post on Post.userId = User.id;
</code></pre><p>而dataloader提供的解法相當美妙，在應用層稍作改變，不影響原本graphql / 不干涉資料庫操作，將 N+1進化成第二優化的查詢條件。</p>
<h3 id="dataloader-介紹">dataloader 介紹</h3>
<p>dataloader作者</p>
<p><a href="https://github.com/facebook/dataloader">dataloader</a> 主要做兩件事 <code>batch</code> &amp; <code>cache</code> ，因為在處理 http request上，為了上資料不過期，大多不會用上 cache，所以這裡僅介紹 batch。<br>
dataloader提供的解法是將異步操作合併，並在Event Loop的一個phase結束後用 process.nextTick 執行。</p>
<p>先看dataloader說明範例</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">DataLoader</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;dataloader&#39;</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">userLoader</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">DataLoader</span>(<span style="color:#a6e22e">keys</span> =&gt; <span style="color:#a6e22e">myBatchGetUsers</span>(<span style="color:#a6e22e">keys</span>));

<span style="color:#75715e">/*  
</span><span style="color:#75715e">myBatchGetUsers是自訂的函式，接收被dataloader batch起來的keys，回傳等同keys長度的Promise  
</span><span style="color:#75715e">*/</span>

<span style="color:#a6e22e">userLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">1</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">user</span> =&gt; <span style="color:#a6e22e">userLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">invitedByID</span>))
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">invitedBy</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`User 1 was invited by </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">invitedBy</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>));

<span style="color:#75715e">// Elsewhere in your application  
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">userLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">2</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">user</span> =&gt; <span style="color:#a6e22e">userLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">lastInvitedID</span>))
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">lastInvited</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`
</span><span style="color:#e6db74">            User 2 last invited $ {
</span><span style="color:#e6db74">                lastInvited
</span><span style="color:#e6db74">            }
</span><span style="color:#e6db74">            `</span>));

<span style="color:#75715e">/*
</span><span style="color:#75715e">userLoader.load(1) 代表要載入，這會被 dataloader batch起來，最後再keys =&gt; myBatchGetUsers(keys)一併處理  
</span><span style="color:#75715e">*/</span>


<span style="color:#75715e">// 接著來看程式碼，總共324行，大概有100行是註解… 非常精簡巧妙的設計
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">key</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">K</span>)<span style="color:#f92672">:</span> Promise <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">V</span> <span style="color:#f92672">&gt;</span> {

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
        <span style="color:#75715e">// Enqueue this Promise to be dispatched.  
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_queue</span>.<span style="color:#a6e22e">push</span>({
            <span style="color:#a6e22e">key</span>,
            <span style="color:#a6e22e">resolve</span>,
            <span style="color:#a6e22e">reject</span>
        });

        <span style="color:#75715e">// 在queue 重新填裝時觸發  
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_queue</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">shouldBatch</span>) {
                <span style="color:#75715e">// If batching, schedule a task to dispatch the queue.  
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">enqueuePostPromiseJob</span>(() =&gt; <span style="color:#a6e22e">dispatchQueue</span>(<span style="color:#66d9ef">this</span>));
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#75715e">// Otherwise dispatch the (queue of one) immediately.  
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">dispatchQueue</span>(<span style="color:#66d9ef">this</span>);
            }
        }
    });

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise</span>;

}
</code></pre></td></tr></table>
</div>
</div><p>load()執行後是回傳一個Promise，注意關鍵的一行 <code>this._queue.push({...})</code> ，這個回傳的Promise resolve方法是被push到 _queue上，而_queue是 dataloader一開始創建時建立的空陣列。</p>
<h4 id="enqueuepostpromisejob">enqueuePostPromiseJob</h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">enqueuePostPromiseJob</span> <span style="color:#f92672">=</span>  
    <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">process</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;object&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">nextTick</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;function&#39;</span> <span style="color:#f92672">?</span>  
    <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">fn</span>) {  
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">resolvedPromise</span>) {  
            <span style="color:#a6e22e">resolvedPromise</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>();  
        }  
        <span style="color:#a6e22e">resolvedPromise</span>.<span style="color:#a6e22e">then</span>(() =&gt; <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">nextTick</span>(<span style="color:#a6e22e">fn</span>));  
    } <span style="color:#f92672">:</span>  
    <span style="color:#a6e22e">setImmediate</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">setTimeout</span>;

<span style="color:#75715e">// Private: cached resolved Promise instance  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">resolvedPromise</span>;
</code></pre></td></tr></table>
</div>
</div><p>resolvedPromise就是用來暫存的 Promise.resolve()，用來執行<code>resolvedPromise.then(() =&gt; process.nextTick(fn))</code> ，fn 是剛才的 <code>() =&gt; dispatchQueue(this)</code> ；<br>
如果環境有 process.nextTick則用，不然用 setImmediate / setTimeout 也可以!</p>
<p>這裡作者打上了25行的註解，大意是說：<br>
ECMAScript 運用 Job / Job Queue描述當下執行結束後的工作順序安排；<br>
(對照Nodejs也就是Event Loop的實作)，Nodejs用 process.nextTick實作 Job的概念，當呼叫了 Promise.then 則會在 global Jobsqueue中加入 PromiseJobs這樣的一個 Job。</p>
<p>dataloader會打包同一個執行的幀(frame) 中的操作，包含在處理PromiseJobs queues 之間的 load也會被一併打包。<br>
這也是為什麼要用<code>resolvedPromise.then(() =&gt; process.nextTick(fn))</code> ，確保在所有的 PromiseJobs之後執行 (*備註一)；</p>
<p>這一段主要是因應cache處理，如果有開啟cache，執行過後一次dataloader會以 Promise.resolve儲存結果，也就是後續不管調用幾次都是立刻回覆結果；<br>
所以下列結果 1 / 5 /6 會被batch在同一個phase執行，而4會到下一個loop去</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">testLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">t</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;1 got &#34;</span>, <span style="color:#a6e22e">t</span>))
Promise.<span style="color:#a6e22e">resolve</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
    <span style="color:#a6e22e">testLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">5</span>)
}).<span style="color:#a6e22e">then</span>(() =&gt; {
    <span style="color:#a6e22e">testLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">6</span>)
})

<span style="color:#a6e22e">setTimeout</span>(() =&gt; {
    <span style="color:#a6e22e">testLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#ae81ff">4</span>)
})
</code></pre></td></tr></table>
</div>
</div><p>而瀏覽器沒有向Nodejs中提供 microtask(process.nextTick)，只能用 macrotask(setImmediate / setTimeout)取代，但會有性能上的影響。</p>
<h3 id="dispatchqueuebatch">dispatchQueueBatch</h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">keys</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">map</span>(({ <span style="color:#a6e22e">key</span> }) =&gt; <span style="color:#a6e22e">key</span>);  
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">batchPromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">batchLoadFn</span>(<span style="color:#a6e22e">keys</span>);

<span style="color:#a6e22e">batchPromise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">values</span> =&gt; {  
    <span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">forEach</span>(({  
        <span style="color:#a6e22e">resolve</span>,  
        <span style="color:#a6e22e">reject</span>  
    }, <span style="color:#a6e22e">index</span>) =&gt; {  
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">values</span>[<span style="color:#a6e22e">index</span>];  
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> Error) {  
            <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">value</span>);  
        } <span style="color:#66d9ef">else</span> {  
            <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);  
        }  
    });  
})
</code></pre></td></tr></table>
</div>
</div><p><code>dispatchQueue</code> 多做一些判斷，最後呼叫dispatchQueueBatch；<br>
在此處取出所有佔存在queue上的keys，並呼叫batchLoadFn，也就是在 new <code>Dataloader((keys)=&gt;{…})</code> 所定義的，執行後就對應queue上的 resolve，也就是把值回傳給 <code>userLoader.load(k).then(value =&gt; ….)</code> 做後續的處理。</p>
<p>總結一下，要使用時先建立 dataloader，並決定對應的 batch loader該如何處理，通常就是放資料庫 batch處理 <code>new Dataloader((keys) =&gt; customBatchLoader(keys))</code> ；<br>
接著定義操作， <code>loader.load(key).then(value =&gt; {})</code> ；<br>
dataloader內部透過 <code>enqueuePostPromiseJob</code> 機制，將一個執行幀內定義的操作都匯集起來，並在 Event Loop phase最後執行；<br>
最後內部呼叫 <code>dispatchQueueBatch</code> ，也就是實際調用 <code>customBatchLoader</code> 的地方，最後 resolve 當初宣告的 <code>loader.load()</code> 。</p>
<h4 id="dataloader簡單範例">dataloader簡單範例</h4>
<p>打印結果，注意 setTimeout會在下一個loop執行，而Promise.resolve()則在同一個 phase被處理掉。</p>
<pre><code>batched by dataloader: [ 1, 2, 3, 5 ]  
content: [ 1, 2, 3, 5 ]  
1 got 2  
[2,3] got [ 3, 4 ]  
batched by dataloader: [ 4 ]  
content: [ 4 ]
</code></pre><p>對應我們要解決的N+1問題，因為Graphql怎麼處理底層呼叫算是個黑盒子，以下是大概示意</p>
<p>1. 原本Graphql的 N + 1問題</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">userList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">getUsers</span>()  
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">post1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">getPostByUserId</span>(<span style="color:#a6e22e">userList</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">id</span>)  
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">post2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">getPostByUserId</span>(<span style="color:#a6e22e">userList</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">id</span>) 
</code></pre></td></tr></table>
</div>
</div><p>&hellip;&hellip;</p>
<p>2. 如果用dataloader轉換</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">userList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">getUsers</span>() 

<span style="color:#75715e">// post請求集中成  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">postLoader</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Dataloader</span>((<span style="color:#a6e22e">keys</span>) =&gt; {  
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">getPostListByUserId</span>(<span style="color:#a6e22e">keys</span>)   
    <span style="color:#66d9ef">return</span> Promise.<span style="color:#a6e22e">all</span>(<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">r</span> =&gt; Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">r</span>)))  
}) 

<span style="color:#75715e">// 照舊一個一個定義還是可以  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">post1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">postLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">userList</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">id</span>)  
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">post2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">postLoader</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">userList</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">id</span>)
</code></pre></td></tr></table>
</div>
</div><h2 id="結語">結語</h2>
<p>原本以為 N+1問題要解決必須深入到改寫資料庫的SQL，例如轉成 SELECT IN，但沒想到有個如此簡潔又漂亮的解法，而且不限定用什麼資料庫，真的是太棒了。</p>
<p>深入底層理解原理，抽象又費時，但我想這樣的投資是值得的，不禁再次感嘆這個Library的精妙，I dont know JS OTZ。</p>
<h3 id="備註">備註</h3>
<p>篇幅有點長，所以把一些細節放在這裡</p>
<h4 id="確保在所有的-promisejobs之後執行">確保在所有的 PromiseJobs之後執行</h4>
<p>這部分要深入了解 Nodejs 執行 microtask與macrotask的順序</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (2);<br>
}).then (() =&gt; {<br>
console.log (9);<br>
process.nextTick (() =&gt; {<br>
console.log (7);<br>
});</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (8);<br>
});<br>
});</p>
<p>process.nextTick (() =&gt; {<br>
console.log (1);<br>
});</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (3);<br>
}).then (() =&gt; {<br>
console.log (6);<br>
});</p>
<p>setImmediate (() =&gt; {<br>
console.log (5);<br>
});</p>
<p>setTimeout (() =&gt; {<br>
console.log (4);<br>
});</p>
<p>////// 打印結果<br>
1<br>
2<br>
3<br>
9<br>
6<br>
8<br>
7 &ndash;&gt; 等同於 dataloader 第一次 batch觸發的時機<br>
4<br>
5</p>
<p>這部分蠻有趣的，一開始Event Loop會先從 nextTick queue開始，所以1會先打印；<br>
接著處理 Promise.resolve()的 promise queue，也就是2 3；<br>
接著 2 3分別又繼續往後resolve 9 6；<br>
8之所以在7之前是因為 Nodejs此時再處理 promise queue，所以會優先處理promise，處理完成後才會再處理 nexttick；<br>
等 microtask都處理完，才會進到其他timer phase與後續的phase處理。</p>
<p>這也是為什麼<code>enqueuePostPromiseJob</code> 要用 <code>promise.resolve(()=&gt;process.nextTick(()=&gt;dispatchQueue(this)))</code> ，對應如果 Promise.resolve().then().then() 中的 Promise都是 resolve了就會自動在同一個 batch處理，對印也就是打印 <code>7</code> 的位置。<br>
如果開啟了 dataloader cache，dataloader 是直接儲存 resolved promise，性能會有顯著的提升。</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/javascript/"> javascript </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
