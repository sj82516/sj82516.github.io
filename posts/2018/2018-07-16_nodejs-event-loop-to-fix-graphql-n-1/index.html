<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.75.1" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。"><meta property="og:title" content="為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題" />
<meta property="og:description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2018/2018-07-16_nodejs-event-loop-to-fix-graphql-n-1/" />
<meta property="article:published_time" content="2018-07-16T12:35:50+00:00" />
<meta property="article:modified_time" content="2018-07-16T12:35:50+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題"/>
<meta name="twitter:description" content="Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題 | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">16</span>
				<span class="rest">Jul 2018</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">為什麼要理解 Nodejs Event Loop：Dataloader 源碼解讀與分析如何解決 Graphql N&#43;1問題</h1>
		</div>
	</div>
	<div class="markdown">
		<p>Nodejs底層是事件驅動，透過 Event Loop處理非同步(non-blocking)操作，讓費時的I/O操作可以交由libuv去呼叫系統事件驅動的 system api或是用 multi thread方式處理，而Main thread則持續處理request或其他運算。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">// copy from nodejs 官網   ┌───────────────────────────┐┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │     pending callbacks     ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       │   (internal use)│  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤  connections, ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │           check           ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘
</code></pre></div><p>簡而言之，Event Loop有許多不同的階段(phase)，每個phase 是個陣列，當完成非同步操作後，會對應將 callback task push到 phase中；<br>
Nodejs會不斷的輪詢 Event Loop並<code>同步執行callback task</code>，直到 Event Loop上都沒有 task且 Main thread也都執行完成，就會退出。</p>
<p>Nodejs一些非同步操作對應的 phase如下<br>
1.<code>setTimeout</code> 屬於 timers <br>
2. <code>pending callbacks</code>主要處理系統錯誤 callback<br>
3. poll 階段則是向系統取得 IO事件<br>
4.<code>setImmediate</code> 屬於 check<br>
5.<code>關閉事件如 socket.on(‘close’, …)</code> 則屬於 close</p>
<p><code>process.nextTick</code> 是在每個phase結束前執行， <code>Promise</code> 屬於 microtask，同樣執行於每個phase結束之前，且在 process.nextTick之前；<br>
所以要小心，不能要遞迴呼叫process.nextTick，會導致整個Event Loop卡住，因為每個process.nextTick都會在phase結束前執行。</p>
<p>以上大致介紹，實際運作複雜許多，附註參考資料：<br>
1. <a href="https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html">https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html</a><br>
2. <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a><br>
3. <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a><br>
4. 在瀏覽器中狀況跟Nodejs執行環境不太相同 <a href="https://github.com/kaola-fed/blog/issues/234#code-analysis-b-a">https://github.com/kaola-fed/blog/issues/234#code-analysis-b-a</a></p>
<p>但我看這個有什麼用? 只要我知道怎麼寫非同步程式碼，了解底層 Event Loop執行順序有什麼意義嗎?</p>
<p>雖然說學習不該帶有太強烈的功利性，追根究底本身就是個樂趣，但這個問題著實困擾我頗久，在這兩天看到了 <code>dataloader</code> 驚為天人的 Library，以下正文開始。</p>
<h2 id="dataloader的用途">dataloader的用途</h2>
<p>dataloader主要用於解決Graphql的N+1問題，稍微簡單介紹一下<br>
Graphql是 FB提出的技術，用來當作新一代的前後端API交互介面，主要是將搜尋的能力交還給前端控制，後端就被動配合；<br>
改善以往 RESTful API在 GET上麻煩的地方，以下為示範</p>
<p>假設有 User / Post / Comment，<br>
User 1 &lt;-&gt; m Post，User可以創建多個Post<br>
User 1 &lt;-&gt; n Comment m &lt;-&gt; 1 Post，User可以在Post下發布 Comment</p>
<p>假設今天我們要顯示某用戶的所有貼文，以REST來講可能是<br>
/user/:userId/post<br>
如果要某用戶下所有貼文帶評論<br>
/user/:userId/post/comment<br>
如果是某用戶某貼文的所有評論<br>
/user/:userId/post/:postId/comment<br>
&hellip;&hellip;</p>
<p>所以在查詢上，前端多一個需求後端就要多一隻API，有點麻煩<br>
如果要省著用同一個API外加query來判斷，就變成資料層或邏輯層一樣要處理</p>
<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br>
而Graphql 則漂亮很多，前端定義好需要的資料格式，後端就會對照回傳(套件輔助)</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-graphql" data-lang="graphql">{    
   User {   
      name,  
      id,  
      Post {  
         title,  
         Comment {  
             content,  
             User <span style="color:#268bd2">......</span>.  
}
</code></pre></div><p>不論是要取得 User，User -&gt; Post， User -&gt; Post -&gt; Comment無限遞迴，都是非常簡單的一件事</p>
<p>後端則是對應好資料擷取，Graphql在後端會過濾把前端需要的欄位回傳，大幅降低網路 payload，非常的簡潔有力。</p>
<p>如果是有大量查詢的應用程式，或是有跨裝置應用，可以考慮導入 Graphql，現在來說方案都已經非常成熟了。</p>
<h3 id="graphql-n1問題">Graphql N+1問題</h3>
<p>但是在讀取巢狀資料的過程中，Graphql會發生N+1問題，例如取得所有用戶下的所有文章<code>{User{Post}}</code> ，這時候因為架構設計的關係，Graphql會先讀取所有的User，接著再針對個別User去讀取Post；<br>
所以資料庫讀取會變成 1 次讀取全部 User + N次個別User讀取Post，例如</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">SELECT \* FROM User; --&gt; 回傳了 [1,2,3,4]  
SELECT \* FROM Post WHERE user_id = 1;  
SELECT \* FROM Post WHERE user_id = 2;  
....

\---&gt; 較為理想情況  
SELECT \* FROM User; --&gt; 回傳了 [1,2,3,4]  
SELECT \* FROM Post WHERE user_id in (1,2,3,4);

\---&gt; 最理想  
SELECT \* FROM User LEFT JOIN Post on Post.userId = User.id;
</code></pre></div><p>而dataloader提供的解法相當美妙，在應用層稍作改變，不影響原本graphql / 不干涉資料庫操作，將 N+1進化成第二優化的查詢條件。</p>
<h3 id="dataloader-介紹">dataloader 介紹</h3>
<p>dataloader作者</p>
<p><a href="https://github.com/facebook/dataloader">dataloader</a> 主要做兩件事 <code>batch</code> &amp; <code>cache</code> ，因為在處理 http request上，為了上資料不過期，大多不會用上 cache，所以這裡僅介紹 batch。<br>
dataloader提供的解法是將異步操作合併，並在Event Loop的一個phase結束後用 process.nextTick 執行。</p>
<p>先看dataloader說明範例</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">var</span> DataLoader <span style="color:#719e07">=</span> require(<span style="color:#2aa198">&#39;dataloader&#39;</span>)
<span style="color:#268bd2">var</span> userLoader <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> DataLoader(keys =&gt; myBatchGetUsers(keys));

<span style="color:#586e75">/*  
</span><span style="color:#586e75">myBatchGetUsers是自訂的函式，接收被dataloader batch起來的keys，回傳等同keys長度的Promise  
</span><span style="color:#586e75">*/</span>

userLoader.load(<span style="color:#2aa198">1</span>)
    .then(user =&gt; userLoader.load(user.invitedByID))
    .then(invitedBy =&gt; console.log(<span style="color:#586e75">`User 1 was invited by </span><span style="color:#2aa198">${</span>invitedBy<span style="color:#2aa198">}</span><span style="color:#586e75">`</span>));

<span style="color:#586e75">// Elsewhere in your application  
</span><span style="color:#586e75"></span>
userLoader.load(<span style="color:#2aa198">2</span>)
    .then(user =&gt; userLoader.load(user.lastInvitedID))
    .then(lastInvited =&gt; console.log(<span style="color:#586e75">`
</span><span style="color:#586e75">            User 2 last invited $ {
</span><span style="color:#586e75">                lastInvited
</span><span style="color:#586e75">            }
</span><span style="color:#586e75">            `</span>));

<span style="color:#586e75">/*
</span><span style="color:#586e75">userLoader.load(1) 代表要載入，這會被 dataloader batch起來，最後再keys =&gt; myBatchGetUsers(keys)一併處理  
</span><span style="color:#586e75">*/</span>


<span style="color:#586e75">// 接著來看程式碼，總共324行，大概有100行是註解… 非常精簡巧妙的設計
</span><span style="color:#586e75"></span>
load(key<span style="color:#719e07">:</span> K)<span style="color:#719e07">:</span> <span style="color:#b58900">Promise</span> <span style="color:#719e07">&lt;</span> V <span style="color:#719e07">&gt;</span> {

    <span style="color:#268bd2">var</span> promise <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> <span style="color:#b58900">Promise</span>((resolve, reject) =&gt; {
        <span style="color:#586e75">// Enqueue this Promise to be dispatched.  
</span><span style="color:#586e75"></span>        <span style="color:#719e07">this</span>._queue.push({
            key,
            resolve,
            reject
        });

        <span style="color:#586e75">// 在queue 重新填裝時觸發  
</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">this</span>._queue.length <span style="color:#719e07">===</span> <span style="color:#2aa198">1</span>) {
            <span style="color:#719e07">if</span> (shouldBatch) {
                <span style="color:#586e75">// If batching, schedule a task to dispatch the queue.  
</span><span style="color:#586e75"></span>                enqueuePostPromiseJob(() =&gt; dispatchQueue(<span style="color:#719e07">this</span>));
            } <span style="color:#719e07">else</span> {
                <span style="color:#586e75">// Otherwise dispatch the (queue of one) immediately.  
</span><span style="color:#586e75"></span>                dispatchQueue(<span style="color:#719e07">this</span>);
            }
        }
    });

    <span style="color:#719e07">return</span> promise;

}
</code></pre></div><p>load()執行後是回傳一個Promise，注意關鍵的一行 <code>this._queue.push({...})</code> ，這個回傳的Promise resolve方法是被push到 _queue上，而_queue是 dataloader一開始創建時建立的空陣列。</p>
<h4 id="enqueuepostpromisejob">enqueuePostPromiseJob</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">var</span> enqueuePostPromiseJob <span style="color:#719e07">=</span>  
    <span style="color:#719e07">typeof</span> process <span style="color:#719e07">===</span> <span style="color:#2aa198">&#39;object&#39;</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">typeof</span> process.nextTick <span style="color:#719e07">===</span> <span style="color:#2aa198">&#39;function&#39;</span> <span style="color:#719e07">?</span>  
    <span style="color:#268bd2">function</span>(fn) {  
        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>resolvedPromise) {  
            resolvedPromise <span style="color:#719e07">=</span> <span style="color:#b58900">Promise</span>.resolve();  
        }  
        resolvedPromise.then(() =&gt; process.nextTick(fn));  
    } <span style="color:#719e07">:</span>  
    setImmediate <span style="color:#719e07">||</span> setTimeout;

<span style="color:#586e75">// Private: cached resolved Promise instance  
</span><span style="color:#586e75"></span><span style="color:#268bd2">var</span> resolvedPromise;
</code></pre></div><p>resolvedPromise就是用來暫存的 Promise.resolve()，用來執行<code>resolvedPromise.then(() =&gt; process.nextTick(fn))</code> ，fn 是剛才的 <code>() =&gt; dispatchQueue(this)</code> ；<br>
如果環境有 process.nextTick則用，不然用 setImmediate / setTimeout 也可以!</p>
<p>這裡作者打上了25行的註解，大意是說：<br>
ECMAScript 運用 Job / Job Queue描述當下執行結束後的工作順序安排；<br>
(對照Nodejs也就是Event Loop的實作)，Nodejs用 process.nextTick實作 Job的概念，當呼叫了 Promise.then 則會在 global Jobsqueue中加入 PromiseJobs這樣的一個 Job。</p>
<p>dataloader會打包同一個執行的幀(frame) 中的操作，包含在處理PromiseJobs queues 之間的 load也會被一併打包。<br>
這也是為什麼要用<code>resolvedPromise.then(() =&gt; process.nextTick(fn))</code> ，確保在所有的 PromiseJobs之後執行 (*備註一)；</p>
<p>這一段主要是因應cache處理，如果有開啟cache，執行過後一次dataloader會以 Promise.resolve儲存結果，也就是後續不管調用幾次都是立刻回覆結果；<br>
所以下列結果 1 / 5 /6 會被batch在同一個phase執行，而4會到下一個loop去</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">testLoader.load(<span style="color:#2aa198">1</span>).then(t =&gt; console.log(<span style="color:#2aa198">&#34;1 got &#34;</span>, t))
<span style="color:#b58900">Promise</span>.resolve().then(() =&gt; {
    testLoader.load(<span style="color:#2aa198">5</span>)
}).then(() =&gt; {
    testLoader.load(<span style="color:#2aa198">6</span>)
})

setTimeout(() =&gt; {
    testLoader.load(<span style="color:#2aa198">4</span>)
})
</code></pre></div><p>而瀏覽器沒有向Nodejs中提供 microtask(process.nextTick)，只能用 macrotask(setImmediate / setTimeout)取代，但會有性能上的影響。</p>
<h3 id="dispatchqueuebatch">dispatchQueueBatch</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">var</span> keys <span style="color:#719e07">=</span> queue.map(({ key }) =&gt; key);  
<span style="color:#268bd2">var</span> batchPromise <span style="color:#719e07">=</span> batchLoadFn(keys);

batchPromise.then(values =&gt; {  
    queue.forEach(({  
        resolve,  
        reject  
    }, index) =&gt; {  
        <span style="color:#268bd2">var</span> value <span style="color:#719e07">=</span> values[index];  
        <span style="color:#719e07">if</span> (value <span style="color:#719e07">instanceof</span> <span style="color:#b58900">Error</span>) {  
            reject(value);  
        } <span style="color:#719e07">else</span> {  
            resolve(value);  
        }  
    });  
})
</code></pre></div><p><code>dispatchQueue</code> 多做一些判斷，最後呼叫dispatchQueueBatch；<br>
在此處取出所有佔存在queue上的keys，並呼叫batchLoadFn，也就是在 new <code>Dataloader((keys)=&gt;{…})</code> 所定義的，執行後就對應queue上的 resolve，也就是把值回傳給 <code>userLoader.load(k).then(value =&gt; ….)</code> 做後續的處理。</p>
<p>總結一下，要使用時先建立 dataloader，並決定對應的 batch loader該如何處理，通常就是放資料庫 batch處理 <code>new Dataloader((keys) =&gt; customBatchLoader(keys))</code> ；<br>
接著定義操作， <code>loader.load(key).then(value =&gt; {})</code> ；<br>
dataloader內部透過 <code>enqueuePostPromiseJob</code> 機制，將一個執行幀內定義的操作都匯集起來，並在 Event Loop phase最後執行；<br>
最後內部呼叫 <code>dispatchQueueBatch</code> ，也就是實際調用 <code>customBatchLoader</code> 的地方，最後 resolve 當初宣告的 <code>loader.load()</code> 。</p>
<h4 id="dataloader簡單範例">dataloader簡單範例</h4>
<p>打印結果，注意 setTimeout會在下一個loop執行，而Promise.resolve()則在同一個 phase被處理掉。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">batched by dataloader: [ 1, 2, 3, 5 ]  
content: [ 1, 2, 3, 5 ]  
1 got 2  
[2,3] got [ 3, 4 ]  
batched by dataloader: [ 4 ]  
content: [ 4 ]
</code></pre></div><p>對應我們要解決的N+1問題，因為Graphql怎麼處理底層呼叫算是個黑盒子，以下是大概示意</p>
<p>1. 原本Graphql的 N + 1問題</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">let</span> userList <span style="color:#719e07">=</span> await db.getUsers()  
<span style="color:#268bd2">let</span> post1 <span style="color:#719e07">=</span> await db.getPostByUserId(userList[<span style="color:#2aa198">0</span>].id)  
<span style="color:#268bd2">let</span> post2 <span style="color:#719e07">=</span> await db.getPostByUserId(userList[<span style="color:#2aa198">1</span>].id) 
</code></pre></div><p>&hellip;&hellip;</p>
<p>2. 如果用dataloader轉換</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">let</span> userList <span style="color:#719e07">=</span> await db.getUsers() 

<span style="color:#586e75">// post請求集中成  
</span><span style="color:#586e75"></span><span style="color:#268bd2">let</span> postLoader <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Dataloader((keys) =&gt; {  
    <span style="color:#268bd2">let</span> res <span style="color:#719e07">=</span> await db.getPostListByUserId(keys)   
    <span style="color:#719e07">return</span> <span style="color:#b58900">Promise</span>.all(res.map(r =&gt; <span style="color:#b58900">Promise</span>.resolve(r)))  
}) 

<span style="color:#586e75">// 照舊一個一個定義還是可以  
</span><span style="color:#586e75"></span><span style="color:#268bd2">let</span> post1 <span style="color:#719e07">=</span> await postLoader.load(userList[<span style="color:#2aa198">0</span>].id)  
<span style="color:#268bd2">let</span> post2 <span style="color:#719e07">=</span> await postLoader.load(userList[<span style="color:#2aa198">1</span>].id)
</code></pre></div><h2 id="結語">結語</h2>
<p>原本以為 N+1問題要解決必須深入到改寫資料庫的SQL，例如轉成 SELECT IN，但沒想到有個如此簡潔又漂亮的解法，而且不限定用什麼資料庫，真的是太棒了。</p>
<p>深入底層理解原理，抽象又費時，但我想這樣的投資是值得的，不禁再次感嘆這個Library的精妙，I dont know JS OTZ。</p>
<h3 id="備註">備註</h3>
<p>篇幅有點長，所以把一些細節放在這裡</p>
<h4 id="確保在所有的-promisejobs之後執行">確保在所有的 PromiseJobs之後執行</h4>
<p>這部分要深入了解 Nodejs 執行 microtask與macrotask的順序</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (2);<br>
}).then (() =&gt; {<br>
console.log (9);<br>
process.nextTick (() =&gt; {<br>
console.log (7);<br>
});</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (8);<br>
});<br>
});</p>
<p>process.nextTick (() =&gt; {<br>
console.log (1);<br>
});</p>
<p>Promise.resolve ().then (() =&gt; {<br>
console.log (3);<br>
}).then (() =&gt; {<br>
console.log (6);<br>
});</p>
<p>setImmediate (() =&gt; {<br>
console.log (5);<br>
});</p>
<p>setTimeout (() =&gt; {<br>
console.log (4);<br>
});</p>
<p>////// 打印結果<br>
1<br>
2<br>
3<br>
9<br>
6<br>
8<br>
7 &ndash;&gt; 等同於 dataloader 第一次 batch觸發的時機<br>
4<br>
5</p>
<p>這部分蠻有趣的，一開始Event Loop會先從 nextTick queue開始，所以1會先打印；<br>
接著處理 Promise.resolve()的 promise queue，也就是2 3；<br>
接著 2 3分別又繼續往後resolve 9 6；<br>
8之所以在7之前是因為 Nodejs此時再處理 promise queue，所以會優先處理promise，處理完成後才會再處理 nexttick；<br>
等 microtask都處理完，才會進到其他timer phase與後續的phase處理。</p>
<p>這也是為什麼<code>enqueuePostPromiseJob</code> 要用 <code>promise.resolve(()=&gt;process.nextTick(()=&gt;dispatchQueue(this)))</code> ，對應如果 Promise.resolve().then().then() 中的 Promise都是 resolve了就會自動在同一個 batch處理，對印也就是打印 <code>7</code> 的位置。<br>
如果開啟了 dataloader cache，dataloader 是直接儲存 resolved promise，性能會有顯著的提升。</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/javascript/"> javascript </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
