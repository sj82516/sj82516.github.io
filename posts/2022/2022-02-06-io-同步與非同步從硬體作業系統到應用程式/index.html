<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.81.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識"><meta property="og:title" content="I/O 同步與非同步：從硬體、作業系統到應用程式" />
<meta property="og:description" content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2022/2022-02-06-io-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-06T01:21:40&#43;00:00" />
<meta property="article:modified_time" content="2022-02-06T01:21:40&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="I/O 同步與非同步：從硬體、作業系統到應用程式"/>
<meta name="twitter:description" content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>I/O 同步與非同步：從硬體、作業系統到應用程式 | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">06</span>
				<span class="rest">Feb 2022</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">I/O 同步與非同步：從硬體、作業系統到應用程式</h1>
		</div>
	</div>
	<div class="markdown">
		<p>從應用程式的角度，執行任務可以分成 I/O bound 與 CPU bound，而 I/O 處理相比於 CPU 運算速度慢好幾個層級，所以當 I/O 還沒準備好時會「主動讓」給其他任務，盡可能地讓 CPU 保持忙碌，等到 「I/O 準備好再重新回到 CPU 執行」</p>
<p>在之前理解 Nodejs non-blocking I/O 時，官方文件 <a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Overview of Blocking vs Non-Blocking</a> 寫到</p>
<pre><code>Any code that is expected to run in a concurrent manner must allow the event loop to continue running as non-JavaScript operations, like I/O, are occurring.
</code></pre><p>Nodejs sdk 有提供 non-blocking I/O 機制，底層 libuv 會處理 event loop 與其餘 I/O 的執行，「當 I/O 執行時可以讓其他的 JavaScript code 繼續運行不被 block」</p>
<p>所有用「」括起來的地方都是我所想不透的，為什麼 I/O 運行時其他 JavaScript Code 可以繼續運行？是因為 Nodejs 有某種特殊的方法知道目前的程式在等待 I/O 所以主動切換不同的任務執行？如果不是 Nodejs runtime 切換，那會是作業系統切換的嗎？該怎麼切換？<br>
又為什麼 I/O 的處理不需要 CPU 的介入嗎？ CPU 怎麼知道 IO 處理完了該繼續往下執行？是不是我的 IO 全部改成 asynchronous 效能就突飛猛進？那為什麼 async io 並不是每個程式語言執行時的預設支援？</p>
<p>同樣最近在看 Golang goroutine <a href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a">Go: Goroutine, OS Thread and CPU Management</a>時又遇到相同的問題，當讀到 goroutine 等待 I/O 回應時 M 會解除 P 並進入等待，讓其他的 M 執行；如果是遇到 network 相關的 I/O 則推至 network poll 等待 network 完成</p>
<p>從應用程式開發者的角度，我們只要知道有<code>神秘的小精靈</code>會幫我們完成 I/O，JavaScript callback / goroutine system call 可以在非同步的狀況下拿到 I/O 回傳的結果就好</p>
<blockquote>
<p>但往下思索，這一切的黑幕背後有滿山滿谷的疑惑</p>
</blockquote>
<h2 id="作業系統與-io-裝置">作業系統與 I/O 裝置</h2>
<p>為了讓開發者可以專注於軟體開發，應用程式多半運行在作業系統之上，透過作業系統提供的統一介面抽象化硬體，並確保單一應用程式不會霸佔硬體資源，所有與 I/O 裝置設備通訊都必須經過作業系統的操控 system call，而這神秘的小精靈就躲在這個環節中</p>
<p>從 high level 的角度來看，大致如下
<img src="/posts/2022/img/0206/io.png" alt="">
分成兩條路線：應用程式主動呼叫與 I/O 裝置主動觸發</p>
<ol>
<li>應用程式呼叫 system call，此時送出 interrupt 切換到 kernel space 執行</li>
<li>system call 操作(如讀寫) I/O 裝置對應的 File，觸發 kernel module 運作，這邊專指 device driver 的部分</li>
<li>當 I/O 裝置完成特定動作，如網卡接收到封包 / 硬碟讀取完資料，會直接透過<code>硬體打出 interrupt 訊號給 CPU</code></li>
<li>CPU 會找到 OS 註冊對應的 <code>interrupt handler 處理</code>，類似於 API server 註冊 api route 等 request 近來就到對應的 handler，mapping 過程稱為 <code>ISR</code></li>
<li>ISR 會找到對應的 device driver 處理</li>
<li>補充：這邊我們只探討跟 I/O 相關的議題，所以 interrupt handler 指的是就是以 kernel module 存在的 I/O device driver，其他還有如 timer interrupt handler 等</li>
</ol>
<p>所以真正有趣的地方在於</p>
<blockquote>
<p>I/O device driver 如何在準備資料的時候釋放 CPU 資源，並在資料準備完成後透過 interrupt 重新向 OS 排程並回傳資料</p>
</blockquote>
<p>以下將以 Linux 為主，探索作業系統與 I/O 裝置的互動</p>
<h2 id="linux-kernel-module-實作">Linux Kernel module 實作</h2>
<p>參考內容 <a href="https://sysprog21.github.io/lkmpg/#introduction">The Linux Kernel Module Programming Guide</a>，現在學習 Linux 真的很幸運有 Jserv 大大的貢獻，用影片與共筆分享在成大教授的課程，並維護這份易讀好懂的 Linux Kernel 開發教學，以下將先以實作切入</p>
<h3 id="kernel-spaceuser-space-與-kernel-module">kernel space、user space 與 kernel module</h3>
<p>先前提到作業系統是為了統一管理硬體而存在，避免應用程式霸佔資源而使其他應用程式無法使用，在執行層面 Linux 拆成 kernel space 與 user space，kernel space 可以操作所以的資源，而一般應用程式執行於 user space 當中，這樣的保護是基於 <code>CPU 所提供</code>，CPU 有不同的模式可以用型，kernel space 有最高權限 (supervisor mode) 而 user space 則是最低權限 (protect mode)</p>
<p>kernel module 是在 <code>Linux runtime 可以動態開關而不需要重新編譯 kernel image 的一段程式</code>，可直接在 kernel space 執行，常見為 I/O device driver</p>
<p>又因為 kernel module 是屬於 kernel 的一部分，所以他們的資源是共享的如記憶體，同樣的如果 <code>kernel module 有問題連帶整個 kernel 都會 crash</code>，以下實驗建議另外開 VM 嘗試，我自己是用 Macbook M1 + Ubuntu 20.20 VM 執行</p>
<h3 id="hello-world---kernel-module">hello world - kernel module</h3>
<p>參考資料 <a href="https://sysprog21.github.io/lkmpg/#hello-and-goodbye">lkmpg - 4.2 Hello and Goodbye</a><br>
讓我們先從最簡單的 hello world 開始，先了解最基本的 kernel module 安裝、卸載與執行過程</p>
<h4 id="1-hello-world">1. hello world</h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* 
</span><span style="color:#75715e"> * hello-1.c - The simplest kernel module. 
</span><span style="color:#75715e"> */</span> 
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt; /* Needed for pr_info() */ </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt; /* Needed by all modules */ </span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">init_module</span>(<span style="color:#66d9ef">void</span>) 
{ 
    pr_info(<span style="color:#e6db74">&#34;Hello world 1.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
 
    <span style="color:#75715e">/* A non 0 return means init_module failed; module can&#39;t be loaded. */</span> 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
} 
 
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cleanup_module</span>(<span style="color:#66d9ef">void</span>) 
{ 
    pr_info(<span style="color:#e6db74">&#34;Goodbye world 1.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
} 
 
MODULE_LICENSE(<span style="color:#e6db74">&#34;GPL&#34;</span>);
</code></pre></td></tr></table>
</div>
</div><p>編寫 kernel module 時，有以下三點必備</p>
<ol>
<li>當 module 安裝時要做什麼：init_module</li>
<li>當 module 移除時要做什麼：cleanup_module</li>
<li>指定 module 的 license：MODULE_LICENSE</li>
</ol>
<p>需要注意的是，這個 program 在輸出時是用 pr_info 而非 printf，原因是參考 <a href="https://www.calleluks.com/the-four-stages-of-compiling-a-c-program/">C 編譯過程</a> 在第三階段 Assembly 產出 object code，如果有外部函式庫呼叫會在第四 Linking 階段補上缺少的 object code；<br>
但是 kernel module 的第四階段不同，他只能解析 kernel 所註冊的 symbol，也就是 kernel 本身提供的 system call，可以在 <code>/proc/kallsyms</code> 查看</p>
<h4 id="2-條列--安裝--移除-kernel-module">2. 條列 / 安裝 / 移除 kernel module</h4>
<p>編譯用的 MakeFile 參考上附連結，產出 module object code 後，可以透過以下指令操作 kernel module</p>
<pre><code>// 條列
$ sudo lsmod
// 安裝
$ sudo insmod {module.ko}
// 移除
$ sudo rmmode {module}
</code></pre><p>可以透過 <code>$ sudo journalctl --since &quot;1 hour ago&quot; | grep kernel</code> 查看近一小時 kernel module 打印結果</p>
<h3 id="device-driver">device driver</h3>
<p><code>所有的裝置在 linux 中都是 file</code>，資料結構可以參考 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include/linux/fs.h</a>，首先要先釐清這邊的 File <code>只存在於 kernel</code>，雖然中文可能都被翻成文件或檔案，但實際上與檔案系統中的檔案概念是不同的! 後者通常是叫做 <strong>inode</strong></p>
<p>所以每一個裝置在 linux 中都是以一個 file 存在，通常儲存於 <code>/dev/</code> 底下，而 device driver 則是 user space 應用程式與 device 溝通的管道，流程大致是</p>
<ol>
<li>driver 向 kernel 註冊取得屬於自己的裝置編號與指定檔案</li>
<li>driver 定義檔案操作</li>
</ol>
<h4 id="1-註冊裝置">1. 註冊裝置</h4>
<p>參考資料 <a href="https://sysprog21.github.io/lkmpg/#device-drivers">lkmpg - 5.6 Device Drivers</a>
先觀察系統中既有的裝置</p>
<pre><code>$ ls -l /dev/
</code></pre><p>可以看到類似的輸出</p>
<pre><code>brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
</code></pre><p>注意到 &ldquo;3, 1&rdquo; 這類型的字串，前面是 major number 後面是 minor number，分別代表 <code>指定 driver, 裝置 id</code>，每個 device driver 都會被分配一個 id，而可能有多個裝置都是由同一個 driver 所驅動，所以有第二個 minor id 讓 driver 區分不同的硬體</p>
<p>接著注意到最前的字元，可能會看到 <code>d / b / c</code> 三種，d 代表 directory 目錄，b 代表 block、c 代表 char；<br>
block device 是指說操作會以 block 為單位，所以有時操作會被 buffer 後才執行，例如硬碟儲存裝置，可以最佳化讀寫的效率；<br>
char device 則沒有 buffer，可以任意讀寫不同的大小，幾乎大多數的裝置都是 char device</p>
<h4 id="2-註冊檔案操作">2. 註冊檔案操作</h4>
<p>當我們想指定 device driver 如何操作檔案時，會定義 file_operations，指定當檔案被讀取 / 寫入時要對應觸發的 handler function，可以看到以下 struct 中幾乎都是定義 <a href="https://chenhh.gitbooks.io/parallel_processing/content/cython/function_pointer.html">function pointer</a></p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> file_operations { 
    <span style="color:#66d9ef">struct</span> module <span style="color:#f92672">*</span>owner; 
    loff_t (<span style="color:#f92672">*</span>llseek) (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>, loff_t, <span style="color:#66d9ef">int</span>); 
    ssize_t (<span style="color:#f92672">*</span>read) (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t <span style="color:#f92672">*</span>); 
    ssize_t (<span style="color:#f92672">*</span>write) (<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>, size_t, loff_t <span style="color:#f92672">*</span>); 
    ssize_t (<span style="color:#f92672">*</span>read_iter) (<span style="color:#66d9ef">struct</span> kiocb <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>); 
    ssize_t (<span style="color:#f92672">*</span>write_iter) (<span style="color:#66d9ef">struct</span> kiocb <span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>); 
    .....
</code></pre></td></tr></table>
</div>
</div><p>補充 file 相關資料 <a href="https://blog.jaycetyle.com/2018/12/linux-fd-open-close/">Linux 系統程式設計 - fd 及 open()、close() 系統呼叫</a>，file 在 Linux 中必須先被 open() 才能執行後續的讀寫操作，open() 時會把檔案稱作 <code>open file</code>，此時會回傳 <code>file descriptor</code>，資料結構就是上面的 file_operations 紀錄每種動作對應的處理方法</p>
<h4 id="3-範例程式碼">3. 範例程式碼</h4>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">71
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">72
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">73
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">74
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">75
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">76
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">77
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">78
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">79
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">80
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">81
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">82
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">83
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">84
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">85
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">86
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">87
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">88
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> file_operations chardev_fops <span style="color:#f92672">=</span> { 
    .read <span style="color:#f92672">=</span> device_read, 
    .write <span style="color:#f92672">=</span> device_write, 
    .open <span style="color:#f92672">=</span> device_open, 
    .release <span style="color:#f92672">=</span> device_release, 
}; 

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">chardev_init</span>(<span style="color:#66d9ef">void</span>) 
{ 
    major <span style="color:#f92672">=</span> register_chrdev(<span style="color:#ae81ff">0</span>, DEVICE_NAME, <span style="color:#f92672">&amp;</span>chardev_fops); 

    <span style="color:#66d9ef">if</span> (major <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) { 
        pr_alert(<span style="color:#e6db74">&#34;Registering char device failed with %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, major); 
        <span style="color:#66d9ef">return</span> major; 
    } 

    pr_info(<span style="color:#e6db74">&#34;I was assigned major number %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, major); 
    cls <span style="color:#f92672">=</span> class_create(THIS_MODULE, DEVICE_NAME); 
    device_create(cls, NULL, MKDEV(major, <span style="color:#ae81ff">0</span>), NULL, DEVICE_NAME); 

    pr_info(<span style="color:#e6db74">&#34;Device created on /dev/%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, DEVICE_NAME); 

    <span style="color:#66d9ef">return</span> SUCCESS; 

} 

<span style="color:#75715e">/* Methods */</span> 
<span style="color:#75715e">/* Called when a process tries to open the device file, like 
</span><span style="color:#75715e"> * &#34;sudo cat /dev/chardev&#34; 
</span><span style="color:#75715e"> */</span> 

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">device_open</span>(<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file) 
{ 
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 

    <span style="color:#66d9ef">if</span> (atomic_cmpxchg(<span style="color:#f92672">&amp;</span>already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN)) 
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EBUSY; 

    sprintf(msg, <span style="color:#e6db74">&#34;I already told you %d times Hello world!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, counter<span style="color:#f92672">++</span>); 
    try_module_get(THIS_MODULE); 

    <span style="color:#66d9ef">return</span> SUCCESS; 
} 

<span style="color:#75715e">/* This function is called whenever a process which has already opened the 
</span><span style="color:#75715e"> * device file attempts to read from it. 
</span><span style="color:#75715e"> */</span> 
<span style="color:#66d9ef">static</span> ssize_t <span style="color:#a6e22e">device_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#75715e">/* see include/linux/fs.h   */</span> 
                           <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buffer, <span style="color:#75715e">/* buffer to be filled  */</span> 
                           size_t length, <span style="color:#75715e">/* length of the buffer     */</span>
                           loff_t <span style="color:#f92672">*</span>offset) 
{ 

    <span style="color:#75715e">/* Number of bytes actually written to the buffer */</span> 
    <span style="color:#66d9ef">int</span> bytes_read <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
    <span style="color:#75715e">/* How far did the process reading the message get? Useful if the message 
</span><span style="color:#75715e">     * is larger than the size of the buffer we get to fill in device_read. 
</span><span style="color:#75715e">     */</span> 
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>message_ptr <span style="color:#f92672">=</span> message; 

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!*</span>(message_ptr <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>offset)) { <span style="color:#75715e">/* we are at the end of message */</span> 
        <span style="color:#f92672">*</span>offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* reset the offset */</span> 
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* signify end of file */</span> 
    } 

    message_ptr <span style="color:#f92672">+=</span> <span style="color:#f92672">*</span>offset; 

    <span style="color:#75715e">/* Actually put the data into the buffer */</span> 
    <span style="color:#66d9ef">while</span> (length <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>message_ptr) { 
        <span style="color:#75715e">/* Because the buffer is in the user data segment, not the kernel 
</span><span style="color:#75715e">         * data segment, assignment would not work. Instead, we have to 
</span><span style="color:#75715e">         * use put_user which copies data from the kernel data segment to 
</span><span style="color:#75715e">         * the user data segment. 
</span><span style="color:#75715e">         */</span> 
        put_user(<span style="color:#f92672">*</span>(message_ptr<span style="color:#f92672">++</span>), buffer<span style="color:#f92672">++</span>); 
        length<span style="color:#f92672">--</span>; 
        bytes_read<span style="color:#f92672">++</span>; 
    } 

    pr_info(<span style="color:#e6db74">&#34;Read %d bytes, %ld left</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, bytes_read, length); 

    <span style="color:#f92672">*</span>offset <span style="color:#f92672">+=</span> bytes_read; 

    <span style="color:#75715e">/* Read functions are supposed to return the number of bytes actually 
</span><span style="color:#75715e">     * inserted into the buffer. 
</span><span style="color:#75715e">     */</span> 
    <span style="color:#66d9ef">return</span> bytes_read; 
} 
</code></pre></td></tr></table>
</div>
</div><p>結論關鍵的程式碼</p>
<ol>
<li>透過 register_chrdev 註冊裝置與指定的 file，系統會返回 major number</li>
<li>註冊 file_operators，可以挑選需要的 handler 註冊</li>
<li>可以注意一下 device_read 註解，裡面有個 system call <code>put_user</code>，因為 driver 是在 kernel mode，而 read 是從 user space 觸發，當今天 driver 想要回傳資料給 user space，不能直接寫入記憶體，而是需要透過 put_user 將記憶體從 kernel space 複製到 user space</li>
</ol>
<p>執行上的細節就不贅述，有興趣可以看參考資料</p>
<h4 id="io-blocking--non-blocking">IO blocking / non-blocking</h4>
<p>參考資料 <a href="https://sysprog21.github.io/lkmpg/#blocking-processes-and-threads">lkmpg - 11 Blocking Processes and threads</a></p>
<p>當應用程式決定操作 I/O 時，device driver 可能面臨資料尚未準備好的情況，此時會透過 <code>O_NONBLOCK</code> flag 決定是否為 block 應用程式，如果 non-blocking 則直接回傳錯誤 <code>-O_NONBLOCK</code> 讓應用程式晚點重試 (polling)，這也就是 Nodejs 所透過的方式，non-blocking I/O (這句話不全然對，還是要看 libuv 針對不同 I/O 的實作，但 non-blocking 就是指這種情況沒錯)</p>
<p>或是應用程式選擇 block mode，此時 device driver 還在等待資料的同時，可以選擇透過 <code>wait_event_interruptible</code> 主動交出 CPU 控制權，避免無謂的佔用 CPU 資源；
同時在 wait 之前會先註冊對應的 <code>wake_up</code> 事件，或是收到 signal 會再叫醒原本沈睡的 process</p>
<p><img src="/posts/2022/img/0206/blocking.png" alt=""><br>
*圖片參考資料 <a href="https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6">https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6</a></p>
<p>重新回來看 blocking 與 non-blocking 的圖，這邊是從應用程式角度出發，blocking I/O 會在 kernel device driver 沒有資料時等待，但從 kernel 角度，如果有指定 interruptable 則作業系統會切換到不同的 process 去，所以也不會有資源浪費的問題 (撇除 context switching 開銷)</p>
<h3 id="system-call">system call</h3>
<p>參考資料 <a href="https://sysprog21.github.io/lkmpg/#system-calls">lkmpg - 10. system call</a></p>
<p>前面實作了簡單的 kernel module，並看到 device driver 可以在 file 發生變化時產生對應的行為，但一般來說應用程式與 kernel 的互動是透過封裝過後的 system call</p>
<p>Linux kernel 會有一張 table <code>sys_call_table</code> 儲存支援的 system call 與對應的 address， 當應用程式需要操作硬體需要指定 system call，例如 open() 開啟檔案 / read() 讀取檔案等，在暫存器寫入指定資料後透過特殊指令 interrupt 通知 CPU 要切換 kernel space 執行 (在 intel 中是 0x80)，進階資料可以參考 <a href="https://en.wikipedia.org/wiki/Protection_ring">CPU protection ring</a></p>
<h4 id="1-從-printf-觀察-system-call">1. 從 printf 觀察 system call</h4>
<p>參考 <a href="https://sysprog21.github.io/lkmpg/#functions-available-to-modules">lkmpg 5.2 Functions available to modules</a>
透過最簡單的 c program printf 來看 system call 的執行</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) 
{ 
    printf(<span style="color:#e6db74">&#34;hello&#34;</span>); 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
}
</code></pre></td></tr></table>
</div>
</div><p>打包後透過 <a href="https://strace.io/">strace</a> 查看 system call 狀況</p>
<pre><code>$ gcc -Wall -o hello hello.c
$ strace ./hello.o
</code></pre><p>打印出蠻多東西，包含一些 memory allocate 的指令等，最終可以看到 <code>write</code> 的 system call 呼叫</p>
<pre><code>write(1, &quot;hello world&quot;, 11hello world)
exit_group(0)
</code></pre><h4 id="2-修改-system-call">2. 修改 system call</h4>
<p>如果我們希望修改 system call，理論上可以直接改 sys_call_table 的 mapping，但基於安全性考量這是無法直接在 runtime 操作的，原因是避免 hacker 直接修改 system call</p>
<p>第二個嘗試可以透過 <code>$sudo grep sys_call_table /proc/kallsyms</code> 找出 sys_call_table 所儲存的實際記憶體位置並替換，但這目前也不行，同樣是因為安全性考量， Linux kernel 在每次 boot 時會動態擾亂 kernel code 跟 data (稱為 KASLR)，增加 hacker 嘗試攻擊的難度</p>
<p>一個可行的做法是透過 <a href="https://ztex.medium.com/kprobe-%E7%AD%86%E8%A8%98-59d4bdb1e1fe">kprobe</a>，這是一個 kernel debug 的工具，當 CPU 執行到中斷點時會保存暫存器狀態，並執行 kprobe 指定的指令，可以透過這種方式去動態調整 system call 執行</p>
<p>但上面的方法在 production 很危險，試想如果有多個 kernel module 去調整 system call，在 restore 時可能會發生意外，不論是復原錯誤或是執行到已經移除的 kernel module，所以建議是直接重新編譯 kernel</p>
<h2 id="cpu-與-hardware-interrupt">CPU 與 Hardware interrupt</h2>
<p>上面大致描述綠線的走向，從 user space 呼叫 system call，觸發對應 device driver 所指定的 file operation</p>
<p>接下來看藍線的部分，當 I/O device 收到外部訊號如網卡收到封包、鍵盤被按下按鈕，如何送出中斷給 CPU 並進入後續的處理</p>
<p>具體內容請參考宅色夫的 <a href="https://hackmd.io/@sysprog/linux-interrupt">Linux 核心設計: 中斷處理和現代架構考量</a>，這邊僅大致提一下流程</p>
<ol>
<li>I/O 裝置送出 Interrupt Request (IRQ)</li>
<li>Hardware controller 整理後送出 interrupt vector 到 CPU</li>
<li>CPU 切換模式立即處理 interrupt，透過 ISR 找到對應的 Interrupt Handler</li>
<li>Interrupt handler 中有分成 top half / bottom half，top half 是不會被其他 Interrupt 中斷，所以一定會當下完成；而 bottom half 則會被排入 softiqr 重新排成，<code>soft</code> 在 OS 中有時是代表不確定何時會被完成</li>
</ol>
<p>實作面的部分參考 <a href="https://sysprog21.github.io/lkmpg/#detecting-button-presses">lkmpg 15.2 Detecting button presses</a>，透過 <code>request_irq</code> 註冊 interrupt request，當指定的 I/O 發生 interrupt 時就會呼叫註冊的 funtion</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ret <span style="color:#f92672">=</span> request_irq(button_irqs[<span style="color:#ae81ff">0</span>], button_isr, 
                    IRQF_TRIGGER_RISING <span style="color:#f92672">|</span> IRQF_TRIGGER_FALLING, 
                    <span style="color:#e6db74">&#34;gpiomod#button1&#34;</span>, NULL); 
</code></pre></td></tr></table>
</div>
</div><p>更多的討論可以參考文件，不同的 CPU 與作業系統有不同的考量，考慮到排程 realtime OS 的設計又會有不同</p>
<h2 id="延伸linux-的-asynchronous-io">延伸：Linux 的 Asynchronous I/O</h2>
<p>現在流行的 network I/O 處理方式是透過 I/O multiplexing，如 Linux 的 epoll，而 asynchrous I/O 看起來十分的迷人，應用程式發出請求後就直接等到作業系統通知，中間完全不用等待，但為什麼目前沒有被大規模採納呢？</p>
<p><img src="/posts/2022/img/0206/io2.png" alt=""><br>
*圖片參考資料 <a href="https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6">https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6</a></p>
<p>參考資料 <a href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring</a>，AIO 在 Linux 2.5 就已經加入了，但持續被詬病例如針對 buffer i/o 還是會變成 synchronous 且 API 難以使用，在 Linux 5.1 後加入了 <code>io_urning</code>新的 AIO API 並持續優化</p>
<p>libuv 有開始討論導入 io_uring 的部分，有人提供 <a href="https://github.com/libuv/libuv/issues/1947#issuecomment-485230126">benchmark</a> 在讀取檔案部分可以比原本的 thread pool 設計更快</p>
<p><a href="https://stackoverflow.com/questions/13407542/is-there-really-no-asynchronous-block-i-o-on-linux">SO: Is there really no asynchronous block I/O on Linux?</a> 裡面有提供很多的相關連結，資料庫如 PostgreSQL / RocksDB 嘗試用 io_uring 提升硬碟讀寫效能，在 networking 方面也有一些嘗試，在另一篇文章 <a href="https://hackmd.io/@shanvia/B1Ds1vlAD">Epoll vs. io_uring 效能測試與比較</a>看起來效能提升不少，CPU 使用率低且能處理更多的 request，之後有機會再深入研究</p>
<h2 id="總結">總結</h2>
<p>突然間不知如何總結，研究的過程比想像中發散，看了很多文件 XD</p>
<p>大抵上從 high level 角度理解了整個 I/O 發生的過程，認識到了「應用程式讀寫 IO 的過程」，中間涉及到 system call / kernel module 的執行，以及 OS context switch 的過程，或許我真正想釐清的是 <code>並非把 I/O 變成 non-blocking / asynchronous 系統效能就會無腦提升</code>，memory 的 copy / interrupt handler 處理等還是會佔用 CPU 時間，可以參考另一篇 <a href="">cloudflare</a> 的整理，真正想做到效能提升有時還是需要 I/O 裝置的升級</p>
<p>研究的過程還有很多沒解釋清楚的地方，例如 File 的資料如何被 I/O 裝置讀寫，需要在涉獵更多硬體相關的知識，或許該來研究樹莓派了 XD</p>
<p>總之，也算是稍稍釐清困擾自己多年的疑惑，希望也可以分享給對於應用程式與 I/O 裝置互動有疑問的人，我在每一段都盡可能留下參照的 lkmpg 章節，強烈推薦有興趣可以讀完整篇，對於 Linux 作業系統有基本的認知</p>
<p>如果有任何不清楚或寫錯的地方，再麻煩留言指教</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/linux/"> linux </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
