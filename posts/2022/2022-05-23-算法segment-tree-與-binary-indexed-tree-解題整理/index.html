<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.81.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="整理 Segment Tree 與 Binary Indexed Tree 解題整理"><meta property="og:title" content="【算法】Segment Tree 與 Binary Indexed Tree 解題整理" />
<meta property="og:description" content="整理 Segment Tree 與 Binary Indexed Tree 解題整理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2022/2022-05-23-%E7%AE%97%E6%B3%95segment-tree-%E8%88%87-binary-indexed-tree-%E8%A7%A3%E9%A1%8C%E6%95%B4%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-23T01:21:40&#43;00:00" />
<meta property="article:modified_time" content="2022-05-23T01:21:40&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【算法】Segment Tree 與 Binary Indexed Tree 解題整理"/>
<meta name="twitter:description" content="整理 Segment Tree 與 Binary Indexed Tree 解題整理"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>【算法】Segment Tree 與 Binary Indexed Tree 解題整理 | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">23</span>
				<span class="rest">May 2022</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">【算法】Segment Tree 與 Binary Indexed Tree 解題整理</h1>
		</div>
	</div>
	<div class="markdown">
		<p>當需要在某一陣列中，求某一段區間的數值和或是最小值，如果是靜態資料，也就是陣列內容不會再改變，我們可以用 <code>prefix sum</code> 在 constant time 取得結果</p>
<p>但如果陣列的值會改變，就需要每次都重新計算 prefix sum，此時的時間複雜度會是 O(N)，有沒有更快的方法呢？</p>
<p>這邊有兩個相似的樹狀結構 <code>Segment Tree / Binary Indexed Tree</code> (又稱 Fenwick Tree) 可以用 <code>O(logN)</code> 解決動態區間和的問題，其中 Segment Tree 可以更廣泛解決區間極值的問題</p>
<p>相關題目</p>
<ol>
<li><a href="https://leetcode.com/problems/range-sum-query-mutable/">307. Range Sum Query - Mutable</a></li>
<li><a href="https://leetcode.com/problems/range-sum-query-2d-mutable/">308. Range Sum Query 2D - Mutable</a></li>
<li><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/">315. Count of Smaller Numbers After Self</a></li>
<li><a href="https://leetcode.com/problems/count-of-range-sum/">327. Count of Range Sum</a></li>
</ol>
<h2 id="segment-tree">Segment Tree</h2>
<p>教學影片：<a href="https://www.youtube.com/watch?v=xztU7lmDLv8">Segment Tree Data Structure - Min Max Queries</a></p>
<p>Segment Tree 與 BIT 的概念雷同，原本我用 prefix sum 遇到更新時要用 O(n) 整個重建，但如果我把<code>區間切小，每次更新只要影響到部分區間</code>，對應的讀取要篩選符合的區間讀取，妥協後 <code>讀取與更新都控制在 log(N)</code>，但區間該怎麼切以及如何實作呢？ 這就是 Segment Tree 與 BIT 不同之處</p>
<p>Segment Tree 用陣列儲存區間值，需要<code>兩倍額外記憶體空間</code>，原陣列放在新陣列的最後，接著往前跟新區間 (parent = idx/2)，如下圖 (從影片截圖而來)
<img src="/posts/2022/img/0522/segment_tree.png" alt=""><br>
所以區間是 2 -&gt; 4 -&gt; 8 這樣往上疊加</p>
<p>初始化程式碼為</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SegmentTree</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    SegmentTree(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        offset_ <span style="color:#f92672">=</span> nums.size();
        nodes_.resize(offset_ <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>);
        <span style="color:#75715e">// 先把原陣列放在最後
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> offset_; i<span style="color:#f92672">++</span>) {
            nodes_[i <span style="color:#f92672">+</span> offset_] <span style="color:#f92672">=</span> nums[i];
        }
        <span style="color:#75715e">// parent = 左 child + 右 child
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> offset_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
            nodes_[i] <span style="color:#f92672">=</span> nodes_[i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> nodes_[i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
        }
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> val) {
        <span style="color:#75715e">// 因為有移動，所以要加上 offset_
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> nodeIdx <span style="color:#f92672">=</span> index <span style="color:#f92672">+</span> offset_;
        <span style="color:#66d9ef">int</span> diff <span style="color:#f92672">=</span> val <span style="color:#f92672">-</span> nodes_[nodeIdx];
        <span style="color:#75715e">// 更新時要更新全部的 parent
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (nodeIdx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            nodes_[nodeIdx] <span style="color:#f92672">+=</span> diff;
            nodeIdx <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> offset_;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nodes_;
};
</code></pre></td></tr></table>
</div>
</div><p>透過 <code>O(N)</code> 即可完成初始化，我們將原陣列放在最後，並往上疊加出多個區間，Update 需要 <code>O(logN)</code>，因為要往前把相關的區間都要更新一次</p>
<p>接著重點是 range query，傳入 left / right (閉區間) 如何在 <code>O(logN)</code> 解決</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumRange</span>(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
    <span style="color:#66d9ef">int</span> nodeLeftIndex <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> offset_;
    <span style="color:#66d9ef">int</span> nodeRightIndex <span style="color:#f92672">=</span> right <span style="color:#f92672">+</span> offset_;
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (nodeLeftIndex <span style="color:#f92672">&lt;=</span> nodeRightIndex) {
        <span style="color:#75715e">// 如果是左指針，且指到區間右側，當下取值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((nodeLeftIndex <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            count <span style="color:#f92672">+=</span> nodes_[nodeLeftIndex];
            nodeLeftIndex<span style="color:#f92672">++</span>;
        }
        <span style="color:#75715e">// 如果是右指針，且指到區間左側，當下取值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((nodeRightIndex <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            count <span style="color:#f92672">+=</span> nodes_[nodeRightIndex];
            nodeRightIndex<span style="color:#f92672">--</span>;
        }
        
        nodeLeftIndex <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        nodeRightIndex <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
    } 
    
    <span style="color:#66d9ef">return</span> count;
}
</code></pre></td></tr></table>
</div>
</div><p>這一段程式碼有點神奇，用圖示大致如下
<img src="/posts/2022/img/0522/segment_tree_explain.png" alt=""></p>
<p>左右分別原陣列長度為 2 , 3 時，如果想要查詢整段區間的指標移動，我們可以觀察出一個重點</p>
<blockquote>
<p>偶數 index 都在區間的左側 / 奇數 index 是在區間的右側</p>
</blockquote>
<p>因為我們是用 left / right 去找區間和，所以我們要找<code>left 往右找與 right 往左找的共同區間</code>，總共分成 4 種情況考慮</p>
<ol>
<li>left 指向偶數：<br>
代表我們會<code>拿整個區間</code>，因為區間的左側是偶數，當目前 left 就指向偶數，代表要取出整個區間</li>
<li>left 指向奇數：<br>
代表我們<code>不可以拿區間當作代表，因為奇數是區間的右側</code>，再往下就到另一個區間，所以我們要直接取值</li>
<li>right 指向偶數： <br>
right 跟 left 邏輯剛好相反，我們<code>只能拿 right 往左的區間，因為偶數是 parent 左側</code>，再往下移就到下個區間，所以要拿當前值</li>
<li>right 指向奇數：<br>
因為<code>奇數是區間的右側</code>，代表我們可以拿整個區間為當前值</li>
</ol>
<p>這部分非常 tricky，簡而言之就是當指針指向的位置可以包含整段區間，則往上指向區間，直到無法包含整段區間則取值，break down 成 2, 3 的案例就比較好理解</p>
<p>影片參考資料是左閉右開的計算方式，但這樣我覺得再取出區間和比較不好做，所以參考 leetcode 解答調整成目前的閉區間算法</p>
<h3 id="307-range-sum-query---mutable-完整解法">307. Range Sum Query - Mutable 完整解法</h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SegmentTree</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    SegmentTree(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        offset_ <span style="color:#f92672">=</span> nums.size();
        nodes_.resize(offset_ <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> offset_; i<span style="color:#f92672">++</span>) {
            nodes_[i <span style="color:#f92672">+</span> offset_] <span style="color:#f92672">=</span> nums[i];
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> offset_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
            nodes_[i] <span style="color:#f92672">=</span> nodes_[i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> nodes_[i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
        }
    }
    
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> val) {
        <span style="color:#66d9ef">int</span> nodeIdx <span style="color:#f92672">=</span> index <span style="color:#f92672">+</span> offset_;
        <span style="color:#66d9ef">int</span> diff <span style="color:#f92672">=</span> val <span style="color:#f92672">-</span> nodes_[nodeIdx];
        <span style="color:#66d9ef">while</span> (nodeIdx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            nodes_[nodeIdx] <span style="color:#f92672">+=</span> diff;
            nodeIdx <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
    }
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumRange</span>(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
        <span style="color:#66d9ef">int</span> nodeLeftIndex <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> offset_;
        <span style="color:#66d9ef">int</span> nodeRightIndex <span style="color:#f92672">=</span> right <span style="color:#f92672">+</span> offset_;
        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> (nodeLeftIndex <span style="color:#f92672">&lt;=</span> nodeRightIndex) {
            <span style="color:#66d9ef">if</span> ((nodeLeftIndex <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                count <span style="color:#f92672">+=</span> nodes_[nodeLeftIndex];
                nodeLeftIndex<span style="color:#f92672">++</span>;
            }
            <span style="color:#66d9ef">if</span> ((nodeRightIndex <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                count <span style="color:#f92672">+=</span> nodes_[nodeRightIndex];
                nodeRightIndex<span style="color:#f92672">--</span>;
            }
            
            nodeLeftIndex <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
            nodeRightIndex <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        } 
        
        <span style="color:#66d9ef">return</span> count;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> offset_;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nodes_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NumArray</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    NumArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        tree_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SegmentTree(nums);
    }
    
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> val) {
        tree_<span style="color:#f92672">-&gt;</span>update(index, val);
    }
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumRange</span>(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
        <span style="color:#66d9ef">return</span> tree_<span style="color:#f92672">-&gt;</span>sumRange(left, right);
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    SegmentTree<span style="color:#f92672">*</span> tree_;
};

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Your NumArray object will be instantiated and called as such:
</span><span style="color:#75715e"> * NumArray* obj = new NumArray(nums);
</span><span style="color:#75715e"> * obj-&gt;update(index,val);
</span><span style="color:#75715e"> * int param_2 = obj-&gt;sumRange(left,right);
</span><span style="color:#75715e"> */</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="binary-index-tree">Binary Index Tree</h2>
<p>1994 年的論文 <a href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=B6DEEDCB6E5C3DE95856CE6E24EB8C53?doi=10.1.1.14.8917&amp;rep=rep1&amp;type=pdf">A New Data Structure for Cumulative
Frequency Tables</a> / 我覺得講得很好的影片 <a href="https://www.youtube.com/watch?v=uSFzHCZ4E-8">Fenwick Tree (Binary Index Tree) - Quick Tutorial and Source Code Explanation</a></p>
<p><img src="/posts/2022/img/0522/bit.png" alt="">
這張圖是從論文截圖而來，實作技巧非常巧妙，他利用 <code>Last Significant Bit (LSB) 來決定區間的範圍</code>，如果 LSB 是 xxx1，則只儲存當前一個數，如果 LSB 是 xx10，則儲存當前兩個數，以此類推，所以可以看到 <code>1, 3 等只會儲存當前 1 個數、8 會儲存往前 8 個數</code></p>
<p><img src="/posts/2022/img/0522/bit_update.png" alt="">
所以更新時會需要更新所有相關區間，上面這張圖是代表當你更新 index i 時，需要往上調整的 bit index，例如更新 idx 1 時，因為 bit[2]、bit[4]、bit[8] 都有包含 idx 1，所以都要一併更新</p>
<p>實作方面非常簡單，透過 <code>2 補數 i &amp; -i 即可取得 LSB</code></p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 1: 0001
</span><span style="color:#75715e">//-1: 1111
</span><span style="color:#75715e">// 1 &amp; -1 =&gt; 0001
</span><span style="color:#75715e">// 6: 0110
</span><span style="color:#75715e">//-6: 1010
</span><span style="color:#75715e">// 6 &amp; -6 =&gt; 0010
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getParent</span>(<span style="color:#66d9ef">int</span> i) {
    <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> (i <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>i);
}
</code></pre></td></tr></table>
</div>
</div><p>讓我們看查詢會變得如何：
<img src="/posts/2022/img/0522/bit_iterate.png" alt="">
圖片表達如果你要某個 prefix sum，你必須往前輪詢的 index，例如要找 idx 1~9 的 prefix sum，則需要 <code>bit[9] + bit[8]</code>，搭配上一張圖 bit[9] 只有儲存 idx 9 這個元素，而 bit[8] 儲存了 idx 1-8 個元素</p>
<p>實作方面同樣透過 2 補數，只是變成往下減</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getNextInterval</span>(<span style="color:#66d9ef">int</span> i) {
    <span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> (i <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>i);
}
</code></pre></td></tr></table>
</div>
</div><p>整體實作</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">71
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">72
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BIT</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    BIT(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> nums.size();
        <span style="color:#75715e">// index 從 1 開始比較好計算
</span><span style="color:#75715e"></span>        bit_.resize(size <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
        arr_.resize(size, <span style="color:#ae81ff">0</span>);
        
        <span style="color:#75715e">// 初始化只要往下一個 parent 加
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 後面 iterate 會疊上去
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> bitIdx <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            bit_[bitIdx] <span style="color:#f92672">+=</span> nums[i];
            arr_[i] <span style="color:#f92672">=</span> nums[i];
            <span style="color:#66d9ef">int</span> parent <span style="color:#f92672">=</span> getParent(bitIdx);
            <span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">&lt;</span> bit_.size()) {
                bit_[parent] <span style="color:#f92672">+=</span> bit_[bitIdx];
            }
        }
    }
    
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> val) {
        <span style="color:#66d9ef">int</span> diff <span style="color:#f92672">=</span> val <span style="color:#f92672">-</span> arr_[index];
        arr_[index] <span style="color:#f92672">=</span> val;

        index<span style="color:#f92672">++</span>;
        <span style="color:#75715e">// 更新記得要全部包含的區間都更新
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (index <span style="color:#f92672">&lt;</span> bit_.size()) {
            bit_[index] <span style="color:#f92672">+=</span> diff;
            index <span style="color:#f92672">=</span> getParent(index);
        }
    }
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">prefixSum</span>(<span style="color:#66d9ef">int</span> index) {
        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        index<span style="color:#f92672">++</span>;
        <span style="color:#75715e">// 取值要往前推
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (index <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            count <span style="color:#f92672">+=</span> bit_[index];
            index <span style="color:#f92672">=</span> getNextInterval(index);
        }
        <span style="color:#66d9ef">return</span> count;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> bit_;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> arr_;
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getParent</span>(<span style="color:#66d9ef">int</span> i) {
        <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> (i <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>i);
    }
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getNextInterval</span>(<span style="color:#66d9ef">int</span> i) {
        <span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> (i <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>i);
    }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NumArray</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    NumArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        tree_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BIT(nums);
    }
    
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> val) {
        tree_<span style="color:#f92672">-&gt;</span>update(index, val);
    }
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumRange</span>(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
        <span style="color:#66d9ef">return</span> tree_<span style="color:#f92672">-&gt;</span>prefixSum(right) <span style="color:#f92672">-</span> tree_<span style="color:#f92672">-&gt;</span>prefixSum(left <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    BIT<span style="color:#f92672">*</span> tree_;
};
</code></pre></td></tr></table>
</div>
</div><h3 id="小結bit-vs-segment-tree">小結：BIT vs Segment Tree</h3>
<p>整理一下兩者</p>
<table>
<thead>
<tr>
<th>比較</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>操作</td>
<td>Segment Tree</td>
<td>Binary Index Tree</td>
</tr>
<tr>
<td>記憶體空間</td>
<td>2 * n</td>
<td>n</td>
</tr>
<tr>
<td>初始化</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>查詢</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
<tr>
<td>更新</td>
<td>O(logN)</td>
<td>O(logN)</td>
</tr>
</tbody>
</table>
<p>此外，使用上兩者有共同侷限 <code>新增 / 移除元素需要重新初始化</code></p>
<h4 id="兩者差異">兩者差異</h4>
<p>兩者都可以解決 #307 這道題目，但看似相同但還是有差異之處，簡單來說 <code>Segment Tree 用途更廣，BIT 只能解決 Prefix Sum 計算</code></p>
<p>例如 Segment Tree 還可以解決<code>區間最小值/區間最大值</code>，而 BIT 是做不到的，為什麼？</p>
<p>因為 BIT 並不是儲存每一個值，而是在初始化就以區間的形式保存，如果是<code>加法這種 invertible 算法</code>，意即我區間儲存 (a+b), 我可以透過 (a+b) - a 還原 b 的值；<br>
但求極值是 non invertable，如果要用 BIT 求極值，那麼在區間計算時就用儲存極值，這樣更新時就會出錯</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-md" data-lang="md">原陣列：[3, 2]
BIT: [, 3, 3(保存區間極值)]
update (0, 1)

BIT: [, 1, ?] =&gt; 無法計算
</code></pre></td></tr></table>
</div>
</div><p>所以 BIT 用途比較侷限，但優點是記憶體空間小，而且 bitwise 的計算速度會快更多</p>
<p>有一篇論文寫可以用兩個 BIT 實作區間極值的查詢，結果還是比 Segment Tree 快上許多，可以參考看看 <a href="https://www.researchgate.net/profile/Mircea-Dima/publication/282222122_Efficient_Range_Minimum_Queries_using_Binary_Indexed_Trees/links/5d5ba500299bf1b97cf7961a/Efficient-Range-Minimum-Queries-using-Binary-Indexed-Trees.pdf?origin=publication_detail">Efficient Range Minimum Queries - using Binary Indexed Trees</a></p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			<a href="/categories/algorithm/"> algorithm </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
