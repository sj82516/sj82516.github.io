<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.81.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Webassembly 實戰分享"><meta property="og:title" content="Webassembly 教學 - 基本運算、陣列處理與指針" />
<meta property="og:description" content="Webassembly 實戰分享" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2020/2020-01-01_webassembly-%E6%95%99%E5%AD%B8-%E5%9F%BA%E6%9C%AC%E9%81%8B%E7%AE%97%E9%99%A3%E5%88%97%E8%99%95%E7%90%86%E8%88%87%E6%8C%87%E9%87%9D/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-01T05:21:40&#43;00:00" />
<meta property="article:modified_time" content="2020-01-01T05:21:40&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Webassembly 教學 - 基本運算、陣列處理與指針"/>
<meta name="twitter:description" content="Webassembly 實戰分享"/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>Webassembly 教學 - 基本運算、陣列處理與指針 | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">01</span>
				<span class="rest">Jan 2020</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">Webassembly 教學 - 基本運算、陣列處理與指針</h1>
		</div>
	</div>
	<div class="markdown">
		<p>近日因為公司專案，要把之前寫好處理圖片的 C++ code 搬移至網頁上，趁機會探索 Web Assembly，未來可以持續移植現有的 C/C++ Library，增加程式的復用性與前端的開發自由度</p>
<p>Webassembly 其實也不是什麼新技術了，在 2017 年已經正式推出，並在<code>四大瀏覽器</code>都能夠使用，Nodejs 也支援，但網路上相對的中文較少，例如記憶體操作、pass by reference 等等較少提及，這也是讓我頭疼許久的地方，花了兩天不斷試錯，趁跨年假期整理並分享</p>
<p>以下兩天是主要參考的文章<br>
<a href="https://hacks.mozilla.org/2017/07/creating-a-webassembly-module-instance-with-javascript/">Creating a WebAssembly module instance with JavaScript</a><br>
<a href="https://developers.google.com/web/updates/2018/03/emscripting-a-c-library">Emscripting a C library to Wasm
</a><br>
<a href="https://becominghuman.ai/passing-and-returning-webassembly-array-parameters-a0f572c65d97">Passing and returning WebAssembly array parameters
</a></p>
<p>Webassembly(Wasm) 主要目的是將其他語言透過編譯方式輸出瀏覽器可以運作的 bytecode，目前除了 C/C++ 外，Rust 也是個熱門的 Wasm 開發語言，周圍的生態系與工具鏈都相對完善；</p>
<p>以下的教學主要專注於使用 <code>Emscripten</code>，Emscripten 功用是將 C/C++ 編譯成 Wasm，除此之外提供 JS 嫁接到 Wasm 這端的處理(膠水程式)，例如說 malloc / free / printf / cout 等等 C/C++ 的標準函式庫支援的函式，<code>目前 Wasm 不能直接 Access，只能透過 JS 去操作 WebAPI</code>，這些都必須在編譯時被納入實作，此外 Wasm 目前還不能像一般的 JS Library 直接 include 就能使用，而是要處理 Memory Mapping 等，這些 Emscripten 都會處理好</p>
<p>主要教學項目有</p>
<ol>
<li>使用 Emscripten 產生範例 code</li>
<li>移植乘法運算 C++ Code</li>
<li>記憶體操作，關於 Pointer &amp; Array</li>
<li>Wasm 總結</li>
</ol>
<h2 id="使用-emscripten-產生範例-code">使用 Emscripten 產生範例 code</h2>
<h3 id="安裝-emscripten">安裝 Emscripten</h3>
<p><a href="https://emscripten.org/docs/getting_started/downloads.html">Emscripten 官方安裝步驟</a>，按照步驟安裝最新版的 Emscripten，確認安裝完成</p>
<blockquote>
<p>emcc &ndash;version</p>
</blockquote>
<h3 id="官方基礎教學-hello-world">官方基礎教學 Hello World</h3>
<p>以下參考 <a href="https://emscripten.org/docs/getting_started/Tutorial.html">官方基礎教學 Hello World</a>，並翻譯(解釋)每個步驟</p>
<h4 id="產生-hello_worldc">產生 hello_world.c</h4>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#586e75">/*
</span><span style="color:#586e75"> * Copyright 2011 The Emscripten Authors.  All rights reserved.
</span><span style="color:#586e75"> * Emscripten is available under two separate licenses, the MIT license and the
</span><span style="color:#586e75"> * University of Illinois/NCSA Open Source License.  Both these licenses can be
</span><span style="color:#586e75"> * found in the LICENSE file.
</span><span style="color:#586e75"> */</span>

<span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;stdio.h&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07"></span>
<span style="color:#dc322f">int</span> <span style="color:#268bd2">main</span>() {
  printf(<span style="color:#2aa198">&#34;hello, world!</span><span style="color:#cb4b16">\n</span><span style="color:#2aa198">&#34;</span>);
  <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
}
</code></pre></div><p>執行</p>
<blockquote>
<p>$ emcc build/hello_world.c -o hello_world.html</p>
</blockquote>
<p>此時會輸出三個檔案，<code>hello_world.html、hello_world.out.js、hello_world.wasm</code></p>
<p><code>-o</code> 指定輸出的檔案與檔名，如果沒有指定會輸出 <code>a.out.js、a.wasm</code>；</p>
<ul>
<li>.html 檔是 Emscripten 方便開發者除錯用的網頁；</li>
<li>.wasm 檔即是 binary 格式的 assembly code，人類無法閱讀；</li>
<li>.js 檔是後續與 JS 整合會需要用到的檔案，也可以直接用 NodeJS 執行</li>
</ul>
<blockquote>
<p>$ node hell_world.out.js</p>
</blockquote>
<p><code>-o</code> 如果有指定 <code>{file_name}.html</code>，則會生成配合的前端頁面，顯示 main function 的執行結果</p>
<p>有了 html 檔，可以使用 http server 用瀏覽器開啟網頁，例如 npm 套件 <code>http-server</code>，在本地端開啟頁面查看結果</p>
<p>C++ 的 code 雷同</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;iostream&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07"></span>
<span style="color:#dc322f">int</span> <span style="color:#268bd2">main</span>() {
  std<span style="color:#719e07">::</span>cout <span style="color:#719e07">&lt;&lt;</span> <span style="color:#2aa198">&#34;hello, world!&#34;</span> <span style="color:#719e07">&lt;&lt;</span> std<span style="color:#719e07">::</span>endl;
  <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
}
</code></pre></div><h2 id="乘法運算並移植到網頁上">乘法運算並移植到網頁上</h2>
<p>上述的 hello_world 主要是檢測環境與工具鍊是否正常，接著開始暖身，用 C++ 寫一個簡單的整數乘法運算，輸入兩個整數，回傳兩整數相乘的結果，<code>著重於如何將 Wasm 整合進前端中</code></p>
<h3 id="產生-multiplycpp">產生 multiply.cpp</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;iostream&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;emscripten/emscripten.h&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07"></span>
<span style="color:#719e07">extern</span> <span style="color:#2aa198">&#34;C&#34;</span>
{
    EMSCRIPTEN_KEEPALIVE
    <span style="color:#dc322f">int</span> <span style="color:#268bd2">multiply</span>(<span style="color:#dc322f">int</span> num1, <span style="color:#dc322f">int</span> num2)
    {
        <span style="color:#719e07">return</span> num1 <span style="color:#719e07">*</span> num2;
    }

    <span style="color:#dc322f">int</span> <span style="color:#268bd2">main</span>()
    {
        <span style="color:#dc322f">int</span> result <span style="color:#719e07">=</span> multiply(<span style="color:#2aa198">2</span>, <span style="color:#2aa198">5</span>);
        std<span style="color:#719e07">::</span>cout <span style="color:#719e07">&lt;&lt;</span> result <span style="color:#719e07">&lt;&lt;</span> std<span style="color:#719e07">::</span>endl;
        <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
    }
}
</code></pre></div><p>預設 Emscripten 產生的 .js 只會執行 main function，如果想要呼叫其他韓式必須在欲輸出 function 前加上 <code>EMSCRIPTEN_KEEPALIVE</code>，在 Comile 時指定參數 <code>-s NO_EXIT_RUNTIME=1</code> 避免 wasm 執行 main function 後直接退出</p>
<p>另外如果是使用 C++ 而不是 C，建議在要輸出的 function 前加上 <code>extern &quot;C&quot;</code>，主要是指定這一段程式碼用 C 的方式編譯，這樣輸出的 function 名稱會保持原狀，可以試著拿掉看看</p>
<blockquote>
<p>$ emcc build/multiply.cpp -s NO_EXIT_RUNTIME=1 -o multiply.js</p>
</blockquote>
<p>此時會輸出 <code>multiply.js &amp; multiply.wasm</code></p>
<p>如果不確定 compiled 出來的檔案能不能運行，建議先 <code>-o {filename}.html</code> 確認可以運作，接著再考慮移植</p>
<h3 id="在網頁使用-multiplyoutjs">在網頁使用 multiply.out.js</h3>
<p>獨立產生 index.html</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="color:#719e07">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color:#268bd2">html</span> lang<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;en&#34;</span>&gt;
  &lt;<span style="color:#268bd2">head</span>&gt;
    &lt;<span style="color:#268bd2">meta</span> charset<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;UTF-8&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">meta</span> name<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;viewport&#34;</span> content<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;width=device-width, initial-scale=1.0&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">meta</span> http-equiv<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;X-UA-Compatible&#34;</span> content<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;ie=edge&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">title</span>&gt;Document&lt;/<span style="color:#268bd2">title</span>&gt;
    &lt;<span style="color:#268bd2">script</span> src<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;./multiply.js&#34;</span>&gt;&lt;/<span style="color:#268bd2">script</span>&gt;
    &lt;<span style="color:#268bd2">script</span>&gt;
      Module.onRuntimeInitialized <span style="color:#719e07">=</span> <span style="color:#268bd2">function</span>() {
        console.log(Module);
        console.log(Module._main());
        console.log(Module._multiply(<span style="color:#2aa198">2</span>, <span style="color:#2aa198">7</span>));
      };
    &lt;/<span style="color:#268bd2">script</span>&gt;
  &lt;/<span style="color:#268bd2">head</span>&gt;
  &lt;<span style="color:#268bd2">body</span>&gt;
    請打開 Console
  &lt;/<span style="color:#268bd2">body</span>&gt;
&lt;/<span style="color:#268bd2">html</span>&gt;
</code></pre></div><p>當我們打開 Console，可以看到 <code>10</code>，以及 <code>Module</code> 這個由 <code>multiply.js</code> export 的 Object，當我們想要使用 Module 當中的參數，需要包在 <code>onRuntimeInitialized</code> listener 當中，等 Module 初始化完成才能調用，Module 裡頭包含非常多的參數與 function，後續會再介紹</p>
<p>而我們輸出的 function 會主動被加上 <code>_</code> 前綴，如果要傳入 int 直接用 JS 的 number 就可以了</p>
<p>甚至如果用 <code>Module._multiply(2, &quot;10&quot;)</code> 都會成功輸出 20，傳入參數時會自動做型別轉換，如果輸入純字串則會回傳 0</p>
<h2 id="記憶體操作關於-pointer--array">記憶體操作，關於 Pointer &amp; Array</h2>
<p>在 C/C++ 中，pointer 很常被直接當作參數傳遞，讓 sub function 直接操作 pointer 指向的記憶體位置，function return 後原 function 可以直接取值出來用</p>
<p>目標是實作一個 filter function biggerThan，只有大於 target 的 element 會被塞進 array_pointer 指向的記憶體位置，size 指向最後的 array length</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#586e75">// 目標
</span><span style="color:#586e75"></span>biggerThan([elements], elements.length, target, <span style="color:#719e07">&amp;</span>array_pointer, <span style="color:#719e07">&amp;</span>size)
</code></pre></div><div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;iostream&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;stdlib.h&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07">#include</span> <span style="color:#719e07">&lt;emscripten/emscripten.h&gt;</span><span style="color:#719e07">
</span><span style="color:#719e07"></span>
<span style="color:#719e07">extern</span> <span style="color:#2aa198">&#34;C&#34;</span>
{
    EMSCRIPTEN_KEEPALIVE
    <span style="color:#dc322f">void</span> <span style="color:#268bd2">biggerThan</span>(<span style="color:#dc322f">int</span> <span style="color:#719e07">*</span>elementList, <span style="color:#dc322f">int</span> elementListLength, <span style="color:#dc322f">int</span> target, <span style="color:#dc322f">int</span> <span style="color:#719e07">**</span>result, <span style="color:#dc322f">int</span> <span style="color:#719e07">*</span>size)
    {
        <span style="color:#719e07">*</span>result <span style="color:#719e07">=</span> (<span style="color:#dc322f">int</span> <span style="color:#719e07">*</span>)malloc(<span style="color:#719e07">sizeof</span>(target) <span style="color:#719e07">*</span> elementListLength);
        std<span style="color:#719e07">::</span>cout <span style="color:#719e07">&lt;&lt;</span> <span style="color:#719e07">*</span>result <span style="color:#719e07">&lt;&lt;</span> std<span style="color:#719e07">::</span>endl;
        <span style="color:#719e07">for</span> (<span style="color:#dc322f">int</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> elementListLength; i<span style="color:#719e07">++</span>)
        {
            <span style="color:#719e07">if</span> (elementList[i] <span style="color:#719e07">&gt;</span> target)
            {
                (<span style="color:#719e07">*</span>result)[<span style="color:#719e07">*</span>size] <span style="color:#719e07">=</span> elementList[i];
                <span style="color:#719e07">*</span>size <span style="color:#719e07">=</span> <span style="color:#719e07">*</span>size <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span>;
            }
        }
        std<span style="color:#719e07">::</span>cout <span style="color:#719e07">&lt;&lt;</span> <span style="color:#2aa198">&#34;size mem position:&#34;</span> <span style="color:#719e07">&lt;&lt;</span> <span style="color:#719e07">*</span>size <span style="color:#719e07">&lt;&lt;</span> <span style="color:#2aa198">&#34;</span><span style="color:#cb4b16">\n</span><span style="color:#2aa198">result mem position:&#34;</span> <span style="color:#719e07">&lt;&lt;</span> result[<span style="color:#2aa198">0</span>] <span style="color:#719e07">&lt;&lt;</span> std<span style="color:#719e07">::</span>endl;
    }
}
</code></pre></div><blockquote>
<p>$ emcc build/bigger_than.cpp -O1 -s NO_EXIT_RUNTIME=1 -o bigger_than.js</p>
</blockquote>
<p><code>-O1</code> 是指名要 compiler optimize 輸出結果，-O1 是初步優化，-O2 / -O3 是更進階耗時的優化，但要小心優化可能會移除需要的功能</p>
<p>接著是 index.html</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="color:#719e07">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color:#268bd2">html</span> lang<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;en&#34;</span>&gt;
  &lt;<span style="color:#268bd2">head</span>&gt;
    &lt;<span style="color:#268bd2">meta</span> charset<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;UTF-8&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">meta</span> name<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;viewport&#34;</span> content<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;width=device-width, initial-scale=1.0&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">meta</span> http-equiv<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;X-UA-Compatible&#34;</span> content<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;ie=edge&#34;</span> /&gt;
    &lt;<span style="color:#268bd2">title</span>&gt;Document&lt;/<span style="color:#268bd2">title</span>&gt;
    &lt;<span style="color:#268bd2">script</span> src<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;./bigger_than.js&#34;</span>&gt;&lt;/<span style="color:#268bd2">script</span>&gt;
    &lt;<span style="color:#268bd2">script</span>&gt;
      Module.onRuntimeInitialized <span style="color:#719e07">=</span> <span style="color:#268bd2">function</span>() {
        <span style="color:#268bd2">const</span> elementList <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array([<span style="color:#2aa198">1</span>, <span style="color:#2aa198">2</span>, <span style="color:#2aa198">3</span>, <span style="color:#2aa198">4</span>, <span style="color:#2aa198">5</span>, <span style="color:#2aa198">6</span>]);
        <span style="color:#268bd2">const</span> elementListBuffer <span style="color:#719e07">=</span> Module._malloc(
          elementList.length <span style="color:#719e07">*</span> elementList.BYTES_PER_ELEMENT
        );
        Module.HEAP32.set(elementList, elementListBuffer <span style="color:#719e07">&gt;&gt;</span> <span style="color:#2aa198">2</span>);

        <span style="color:#268bd2">const</span> target <span style="color:#719e07">=</span> <span style="color:#2aa198">2</span>;
        <span style="color:#268bd2">const</span> result <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array(<span style="color:#2aa198">1</span>);
        <span style="color:#268bd2">const</span> resultBuffer <span style="color:#719e07">=</span> Module._malloc(
          result.length <span style="color:#719e07">*</span> result.BYTES_PER_ELEMENT
        );
        Module.HEAP32.set(result, resultBuffer <span style="color:#719e07">/</span> result.BYTES_PER_ELEMENT);

        <span style="color:#268bd2">const</span> size <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array(<span style="color:#2aa198">1</span>);
        <span style="color:#268bd2">const</span> sizeBuffer <span style="color:#719e07">=</span> Module._malloc(size.length <span style="color:#719e07">*</span> size.BYTES_PER_ELEMENT);
        Module.HEAP32.set(size, sizeBuffer <span style="color:#719e07">/</span> size.BYTES_PER_ELEMENT);

        console.log(
          <span style="color:#586e75">`mem position:\nsizeBuffer: </span><span style="color:#2aa198">${</span>sizeBuffer<span style="color:#2aa198">}</span><span style="color:#586e75"> resultBuffer: </span><span style="color:#2aa198">${</span>resultBuffer<span style="color:#2aa198">}</span><span style="color:#586e75">`</span>
        );
        Module._biggerThan(
          elementListBuffer,
          elementList.length,
          target,
          resultBuffer,
          sizeBuffer
        );

        <span style="color:#268bd2">const</span> sizeInMem <span style="color:#719e07">=</span>
          Module.HEAP32[sizeBuffer <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT];
        <span style="color:#268bd2">const</span> resultRef <span style="color:#719e07">=</span>
          Module.HEAP32[resultBuffer <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT];
        <span style="color:#268bd2">const</span> resultInMem <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array(sizeInMem);

        console.log(
          resultBuffer,
          resultRef,
          Module.HEAP32[resultRef <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span>]
        );
        <span style="color:#719e07">for</span> (<span style="color:#268bd2">let</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> sizeInMem; i<span style="color:#719e07">++</span>) {
          resultInMem[i] <span style="color:#719e07">=</span>
            Module.HEAP32[resultRef <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT <span style="color:#719e07">+</span> i];
        }

        console.log(sizeInMem, resultInMem);

        Module._free(resultBuffer);
        Module._free(sizeBuffer);
        Module._free(elementListBuffer);
      };
    &lt;/<span style="color:#268bd2">script</span>&gt;
  &lt;/<span style="color:#268bd2">head</span>&gt;

  &lt;<span style="color:#268bd2">body</span>&gt;
    請打開 Console
  &lt;/<span style="color:#268bd2">body</span>&gt;
&lt;/<span style="color:#268bd2">html</span>&gt;
</code></pre></div><h4 id="arraybuffer--typedarray">ArrayBuffer &amp; TypedArray</h4>
<p>在開始之前，必須先了解 JS 如何處理 binary data，在 JS 中 binary data 是以 <code>ArrayBuffer</code> 表示，ArrayBuffer 只能讀不能做其他的操作，只能透過 <code>TypedArray</code> 與 <code>Dataview</code>轉換，而 Wasm 中會用到的是 TypedArray</p>
<p>TypedArray 有許多不同長度的類型，如 Int8Array / Int16Array，數字代表每個 element 的 bit 長度</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> buffer <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> ArrayBuffer(<span style="color:#2aa198">2</span>);
<span style="color:#268bd2">const</span> i8 <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int8Array(buffer);
i8[<span style="color:#2aa198">0</span>] <span style="color:#719e07">=</span> <span style="color:#2aa198">100</span>;
i8[<span style="color:#2aa198">1</span>] <span style="color:#719e07">=</span> <span style="color:#2aa198">20</span>;
<span style="color:#268bd2">const</span> i16 <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int16Array(buffer);
console.log(i16[<span style="color:#2aa198">0</span>]); <span style="color:#586e75">// 5220，因為是 0x14 0x64
</span></code></pre></div><p>如果兩個 Type Array 從同一個 ArrayBuffer 生成，則兩者改動都會互相影響，如果遇到不同類型互轉，則高位在後低位在前，所以 <code>i16[0] = i8[1] * 2^8 + i8[0]</code>
<img src="https://media.prod.mdn.mozit.cloud/attachments/2014/09/16/8629/80522bcbdb9d77c4a4c72a289365ea63/typed_arrays.png" alt=""></p>
<p>在 C/C++中，有多種不同長度的型別，例如 char / int / float / double 加上 signed / unsigned 等，就會一一對照到 JS 的 Typed Array
<img src="/posts/img/typedarray.jpeg" alt=""></p>
<h4 id="pass-array-by-pointer">Pass Array by pointer</h4>
<p>當我們要讓 C++ 讀取陣列，我們不能直接傳遞陣列，而是先在 JS 中把陣列放進 Memory &ndash;&gt; 接著傳遞 Memory 中的位址 &ndash;&gt; 從 Memory 位址讀取陣列的元素</p>
<p>在 Wasm 中，一開始初始化會需要 Memory Object，表明整個 Wasm 能夠使用多大的記憶體，接著把資料放進記憶體當中，並取得存放的位址，將位址從 JS 傳遞給 C++，C++ 去相對應的記憶體空間將值取出</p>
<p>Emscripten 簡化這個過程，改用 <code>_malloc</code> 去取得記憶體空間，並由對應類別大小的 HEAP 塞入空間，此時會拿到記憶體位址</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> elementList <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array([<span style="color:#2aa198">1</span>, <span style="color:#2aa198">2</span>, <span style="color:#2aa198">3</span>, <span style="color:#2aa198">4</span>, <span style="color:#2aa198">5</span>, <span style="color:#2aa198">6</span>]);
<span style="color:#268bd2">const</span> elementListBuffer <span style="color:#719e07">=</span> Module._malloc(
  elementList.length <span style="color:#719e07">*</span> elementList.BYTES_PER_ELEMENT
);
Module.HEAP32.set(elementList, elementListBuffer <span style="color:#719e07">&gt;&gt;</span> <span style="color:#2aa198">2</span>);
</code></pre></div><p>這段話的翻譯是</p>
<ol>
<li>產生 [1, 2, 3, 4, 5, 6] 陣列，每個元素是 32 bits (4 bytes) 大，剛好對應 C++ 的 int 大小</li>
<li>索取記憶體空間，_malloc 需指定要多大的 bytes 空間，此例需要 6 * 4 = 24 bytes，elementListBuffer 此時代表這塊記憶體的起始位置，每間隔 4 個 bytes 就是陣列的下一個元素</li>
<li>因為每個元素是 32 bits，所以用 HEAP32 塞資料，這邊 elementListBuffer &raquo; 2 是因為每個儲存單位是 4 bytes， &raquo; 2 代表 / 4<br>
可以想像是大小抽屜，JS 中操作最小單位是單一個 byte，如果是 Int8Array 則是一個抽屜對應一個單位，但如果是 Int32Array，就是一個抽屜對應四個單位，所以編號(位址)也會比小抽屜少四分之一</li>
</ol>
<p>在 C++ 當中，要輪詢 elementList 陣列的值，就只要</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#719e07">for</span> (<span style="color:#dc322f">int</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> elementListLength; i<span style="color:#719e07">++</span>)
{
    elementList[i]....
}
</code></pre></div><h4 id="pointer">Pointer</h4>
<p>在 Wasm 中，pointer 是 32 bits，所以針對 result / size 都是用 Int32Array，即使 size 是整數而非&quot;陣列&quot;，但是一樣用 Int32Array 宣告</p>
<p>先看 size，宣告方式相同，最後要取值時，同樣是去 Memory 中的位置找，記得一樣要做位址座標的切換</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> size <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array(<span style="color:#2aa198">1</span>);
<span style="color:#268bd2">const</span> sizeBuffer <span style="color:#719e07">=</span> Module._malloc(size.length <span style="color:#719e07">*</span> size.BYTES_PER_ELEMENT);
Module.HEAP32.set(size, sizeBuffer <span style="color:#719e07">/</span> size.BYTES_PER_ELEMENT);

<span style="color:#586e75">// 取值
</span><span style="color:#586e75"></span><span style="color:#268bd2">const</span> sizeInMem <span style="color:#719e07">=</span> Module.HEAP32[sizeBuffer <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT];
</code></pre></div><h5 id="pointer-of-pointer">Pointer of pointer</h5>
<p>再來是比較特別的 result，這其實是一個 pointer of pointer，先看 C++ 實作</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#719e07">*</span>result <span style="color:#719e07">=</span> (<span style="color:#dc322f">int</span> <span style="color:#719e07">*</span>)malloc(<span style="color:#719e07">sizeof</span>(target) <span style="color:#719e07">*</span> elementListLength);
</code></pre></div><p>在 JS 層我並沒有先建立整個陣列，而是到了 C++ 才用 malloc 方式去索取陣列的記憶體空間，此時新增加的記憶體空間 JS 並不知道在哪裡，所以我必須想辦法回傳，此時可以透過 return value，我選擇直接修改 result 的值，暫存記憶體位址，再用這個位址去找真正的陣列所在處</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> resultRef <span style="color:#719e07">=</span> Module.HEAP32[resultBuffer <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT];
<span style="color:#268bd2">const</span> resultInMem <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> Int32Array(sizeInMem);

<span style="color:#719e07">for</span> (<span style="color:#268bd2">let</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> sizeInMem; i<span style="color:#719e07">++</span>) {
  resultInMem[i] <span style="color:#719e07">=</span> Module.HEAP32[resultRef <span style="color:#719e07">/</span> Int32Array.BYTES_PER_ELEMENT <span style="color:#719e07">+</span> i];
}
</code></pre></div><p>唸起來很擾口，但也就是多一次的記憶體位址的轉換</p>
<h4 id="free">free</h4>
<p>最後別忘了要釋放索取的記憶體，避免 Memory leak</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">Module._free(resultBuffer);
</code></pre></div><h2 id="總結">總結</h2>
<p>WebAssembly 讓網頁開發的「部分功能」可以外包給給其他語言，讓網頁開發的疆域與技術更加的彈性與兼容，甚至未來可以有更多的跨語言協作的可能，十分令人期待</p>
<p>這一篇教學介紹了 Emscripten 工具，與 C/C++ 編譯出的 Wasm 如何跟 JS 互動，包含基本的整數運算、陣列操作、Pointer 與記憶體存取</p>
<p>下一篇預計介紹不使用 Emscripten，直接用 Clang 編譯 Wasm，還原到最簡單原始的狀態去認識 Wasm</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/%e6%87%89%e7%94%a8%e9%96%8b%e7%99%bc/"> 應用開發 </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
