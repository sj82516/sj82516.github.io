<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.81.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Timsort 廣泛應用在 Python / Android，現在 V8 JS Engine 也改用 Timsort 當作預設的排序法，此篇分享 Timsort實作的細節 "><meta property="og:title" content="V8 內的排序演算法 — Timsort" />
<meta property="og:description" content="Timsort 廣泛應用在 Python / Android，現在 V8 JS Engine 也改用 Timsort 當作預設的排序法，此篇分享 Timsort實作的細節 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yuanchieh.page/posts/2019/2019-08-09_v8-%E5%85%A7%E7%9A%84%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95-timsort/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-09T05:41:03&#43;00:00" />
<meta property="article:modified_time" content="2019-08-09T05:41:03&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="V8 內的排序演算法 — Timsort"/>
<meta name="twitter:description" content="Timsort 廣泛應用在 Python / Android，現在 V8 JS Engine 也改用 Timsort 當作預設的排序法，此篇分享 Timsort實作的細節 "/>

	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<title>V8 內的排序演算法 — Timsort | Yuanchieh&#39;s Blog</title><meta name="google-site-verification" content="Zmi0DCwmB_paCE45T_J552m4NDDpaMH6dqZLMYgM7Js" />
</head>
<body><header>
	
	<div id="avatar">
		<a href="https://yuanchieh.page">
		  <img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" alt="Yuanchieh&#39;s Blog">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://yuanchieh.page">Yuanchieh&#39;s Blog</a></h2></div>
	<div id="title-description"><p id="subtitle">生命是長期而持續的累積</p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/sj82516"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:sj82516@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li>
					<li><a href="/index.xml"><i title="RSS" class="icons fas fa-rss"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/posts">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">09</span>
				<span class="rest">Aug 2019</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">V8 內的排序演算法 — Timsort</h1>
		</div>
	</div>
	<div class="markdown">
		<p>在最新的一期 Javascript Weekly 中看到 V8 部落格 2019/07/09 的文章，裡頭提到 ECMAScript Spec 將 Sorting 改成 <code>Stable</code>，也就是如果排序上兩個元素順序相同，則最終排序完成的陣列中的相同順序元素，會依照原本的順序排列，例如</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">[{name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;a&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">2</span>}, {name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;b&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">2</span>}, {name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;c&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">1</span>}]
</code></pre></div><p>依照 value 排序 ===&gt;</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">[{name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;c&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">1</span>}, {name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;a&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">2</span>}, {name<span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;b&#39;</span>, value<span style="color:#719e07">:</span> <span style="color:#2aa198">2</span>}]

<span style="color:#586e75">// a 跟 b 順序相同，而 a 維持在 b 之前
</span></code></pre></div><p>先前的 Spec 沒有特別定義，所以各平台的實作不同，之後Chrome 70+ 與 Nodejs 12+ 開始支援 Stable Sorting，其餘的平台還不確定。</p>
<h2 id="timsort">TimSort</h2>
<p><a href="https://en.wikipedia.org/wiki/Timsort"><strong>Timsort</strong></a></p>
<p>作者原文</p>
<p><a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">http://svn.python.org/projects/python/trunk/Objects/listsort.txt</a></p>
<p>參考自維基，Tim Sort 原理是由 Tim Peter 基於 Merge Sort 與 Insertion Sort所設計的排序演算法，Tim 觀察到實際世界的陣列多半是<code>由多個部分排序的數列所組成</code>，所以 Tim Sort 會先找出陣列中排序好的子陣列(稱為 run)，不斷的合併 run 直到整體排序結束，基於這樣的原理可以設計出更好的排序演算法。</p>
<p>作者提到，random array 最佳的排序法被 bound 在 O(nlog n) (文中是用 O(n!)，兩者等價)，但是不同的 O(nlog n)等級的 sorting 演算法離 O(log n) 的極限值還是有差距，Timsort 大概距離極限值 1%，而一般的 quick sort 則是 39% 之遠；<br>
與原本 Python native 的 sample sort 相比兩者差異不大，random array Timsort 較差，但是 Timsort 針對部分排序的陣列表現更佳。</p>
<p>目前 Python、Android SDK、Java SDK、Chrome 、Swift 內部的 sort() 都採用 Tim Sort，應用非常廣泛。</p>
<h3 id="基本觀念">基本觀念</h3>
<p><a href="https://www.drmaciver.com/2010/01/understanding-timsort-1adaptive-mergesort/"><strong>Understanding timsort, Part 1: Adaptive Mergesort</strong></a></p>
<p>直接死磕 Wiki有點看不懂，每個英文句子都懂但就是無法理解背後設計的含義，網路上看到這篇最淺顯易懂的解釋，以下簡單摘錄重點幫助理解。</p>
<p>Tim Sort 脫胎於 Merge Sort，試著用這三個方向去優化 Merge Sort</p>
<ol>
<li>讓 merge 過程更快</li>
<li>讓 merge 次數變少</li>
<li>在特殊條件下用更好的方式取代 Merge Sort</li>
</ol>
<p>試想有個陣列</p>
<p>{5, 6, 7, 8, 9, 10, 1, 2, 3}</p>
<p>用怎樣的方式可以用最少的 merge 完成排序？</p>
<p>直覺來看，把陣列拆成兩個已經按照升序排序的陣列 <code>{5,6,7,8,9,10}</code> 與 <code>{1,2,3}</code> 然後合併，只需要一次 merge 就可以完成</p>
<p>假使我們先提出一個演算法：找到陣列開頭最長的連續升序排序的陣列，其餘當作第二子陣列，以遞迴方式持續處理</p>
<p>這個演算法利用了已排序的陣列去減少 merge 的次數，但有個問題 如果陣列剛好是倒序，就會落入 worst case O(n²) ，稱不上是個理想的排序演算法，所以實作時會補上如果發現連續的子陣列是降序，則 in memory 反序。</p>
<p><strong>先退回最基本的 Merge Sort</strong></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">{{1}, {2}, {3}, {4}}  
{{1, 2}, {3, 4}}  
{{1, 2, 3, 4}}
</code></pre></div><p>這是 Merge Sort 的流程，將陣列分拆到為一然後在逐步 merge，我們將第一步分拆的過程改為已排序好的區間(稱為 Run)，然後進行 merge。</p>
<p>Tim Sort 在 merge 時會盡量 Balance，所以會設定 minrun，如果這次的 RUN 長度小於 minrun，則會補足到 minrun長度後，接著使用 binary insertion sort，如何選擇 minrun 是個學問，作者提到一個實務上的設定是</p>
<p>take the first 6 bits of N, and add 1 if any of the remaining bits are set</p>
<p>N 是陣列長度，最主要是希望如果遇到 random array，則N 盡可能被 minrun 切成 2 次方倍 RUN，在 merge 時可以最平衡。</p>
<blockquote>
<p>minRun 是希望剩餘的數再分minrun的時候能盡可能是2的冪次，後續再做merge的時候才能兩兩合併效率較高；<br>
實作上會不斷將n除以二 直到n&lt;MIN_MERGE，而中間只要有任何一次不能被2整除，最終結果就加一，這樣取的minRun會讓分組最接近2冪<br>
(感謝公司同事 Frank 補充)</p>
</blockquote>
<p>例如 N = 2112，minrun = 32 會切成 66個RUN，則合併時最後會變成 2048 + 64，兩者非常不平衡；<br>
但如果 minrun 是 33，則會被切成 64個RUN，切割成 2的 n 次方個數合併起來就很平衡 (perfect balanced)。</p>
<h3 id="決定何時-merge"><strong>決定何時 merge?</strong></h3>
<p>Tim Sort 會用一個 Stack 暫存 RUN，並不是一開始就輪詢整個陣列產生RUN，而是逐步進行，避免要用掉過多的記憶體。</p>
<p>基於這兩個原則，Tim Sort 實作上有個函式 <code>merge_collapse</code> ，這個函式主要判斷目前 Stack 最上層的三個 RUN 是否符合以下規則</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">1\.  A &gt; B+C  
2\.  B &gt; C
</code></pre></div><p>如果符合，則將下一個 RUN push 到 Stack上，反之則比較 A跟Ｃ，較小者與 B merge，例如</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A:30  B:20  C:10  
A &lt;= B + C 所以不符合 merge_collapse，又因為 C &lt; A，所以 C 跟 B merge 變成 A:30 BC: 30
</code></pre></div><p>透過這樣的方式，讓保留在 Stack 上的 RUN 長度平衡，另一個重點是合併只能是 A+(B+C) 或是 (A+B)+C，因為要保持 Stable，所以 merge 一定要相鄰兩個 RUN。</p>
<h4 id="如何-merge">如何 merge</h4>
<p>要將兩個相鄰子陣列，用 in memory 方式 merge 在實作上會有困難，實務上因為要造成大量的 memory 操作其實也不會比較快，所以 Tim Sort 使用一塊暫存記憶區，大小為 (A,B) 陣列的最小長度</p>
<p>如果 A &lt; B，則先將 A 放進暫存記憶區，最直覺的方式是 A 跟 B 從頭開始比對，小的放進 A 的位置，直到 A 跟 B 排序完成，如同一般 merge sort 的做法，又稱為 <code>one-pair-at-a-time</code>。</p>
<p>但因為 A 跟 B 都已經是排序好的陣列，所以有個優化的方式是找出 B[0] 在 A陣列排序的位置，然後A該位置之前都是小於 B[0]，所以可以整段放進去，接著找剩餘A[0]在 B的位置，不斷輾轉直到排列結束，也就是 <code>gollaping mode</code>。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A: [1,2,3,7,8,9] B: [4,5,6,8,9,10,11]  
A &lt; B，所以 A 放入暫存區 temp

先找 B[0] 在 A 的位置，也就是在 A[2]、A[3]之間，因為 B[0] &gt; A[2]，也就是 A[0]~A[2] 可以直接放回去，變成  
A: [1,2,3] B: [4,5,6,8,9,10,11]  
temp: [7,8,9]

接著找 temp[0] 在 B的位置，也就是 B[2]、B[3] 之間，變成  
A: [1,2,3,4,5,6] B: [9,10,1]  
temp: [7,8,9]

接著找 B[0] 在 temp 的位置，持續反覆
</code></pre></div><p>這優化的方式大多數是有正向的效果，但如果遇到 random array，可能會比原本的 <code>one-pair-at-a-time</code> 還要慢，但作者提及</p>
<blockquote>
<p>It&rsquo;s generally true in this algorithm that we&rsquo;re willing to gamble a little to win a lot, even though the net expectation is negative for random data</p>
</blockquote>
<p>風險與收益評估後，整體還是正向的，所以就決定採用。</p>
<p>實務上有一個固定參數 MIN_GALLOP =7 與變動參數 minGallop，一開始採用 <code>one-pair-at-a-time mode</code>，一直到某個陣列的首位元素持續大於另一陣列，才切換到 <code>galloping mode</code>；<br>
如果 galloping search(看後續)找到的元素位置小於MIN_GALLOP 則退回 <code>one-pair-at-a-time mode</code>，反之則持續用 <code>galloping mode</code>；<br>
如果一直在 galloping search，會下修 minGallop，也就是更容易進入 galloping mode 的意思。</p>
<p>反覆執行到兩個陣列合併完成</p>
<h4 id="找出某數在已排序陣列中的位置">找出某數在已排序陣列中的位置</h4>
<p>進入 galloping mode 時，會需要不斷的查找某數在已排序陣列的位置，假設 A 是較短的陣列，一開始找 A[0] 在 B陣列應排序的位置，最直覺的方式是用 binary search，但這邊作者改採用另一個演算法 <code>galloping search</code>(又稱 expotential search)</p>
<p>相較於 binary search 不斷對半切查找，galloping search 是比對 <code>(2^k)th</code> 元素，也就是找 1, 3, 5, 7, 15 這樣的方式，當找到 <code>(2^(j-i)) &lt; x &lt; (2^j)</code> 時，在改用 binary search。</p>
<p>比較這兩者， galloping search 的時間複雜度是 <code>O(i)</code>，i 指的是 x 在查詢陣列的位置，如果 i 很前面那效率就會很高；<br>
binary search 時間複雜度為 <code>O(n)</code>，n 是查詢陣列的長度。<br>
而 n ≥ i ，所以從時間複雜度來看 galloping search 會比 binary search 還要快一些。</p>
<p>但實際上，因為陣列是隨機的，採用 galloping search 可能會比 linear search 慢，作者列出 galloping search 對比 linear search 的計算花費，可以看到在 i=7 之前 galloping search 會需要更多的比較次數，而比較是很花計算資源的，所以 MIN_GALLOP預設是 7。</p>
<h3 id="總結演算法">總結演算法</h3>
<p>稍微總結一下，Timsort 維護一個 Stack，Stack 上會 push 已排序的連續子陣列，並透過 <code>merge_collapse</code> 判斷是否先 merge Stack 上的陣列，盡量保持子陣列的長度接近；</p>
<p>merge 過程，則是動態在 one-pair-at-a-time 與 galloping mode 中切換，用有效率的方式合併兩個已排序好的陣列；</p>
<h3 id="進入程式碼">進入程式碼</h3>
<p>最終還是要看一下代碼，原作者是用 C寫，因為 java code 比較好閱讀參考 android TimSort 實作</p>
<p><a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/util/TimSort.java"><strong>luni/src/main/java/java/util/TimSort.java - platform/libcore - Git at Google</strong></a></p>
<p>也有 js 版，但是註解較少</p>
<p><a href="https://github.com/mziccard/node-timsort/blob/master/src/timsort.js"><strong>mziccard/node-timsort</strong></a></p>
<p><code>minRunLength()</code> 定義如何決定 minrun的值</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#dc322f">int</span> r <span style="color:#719e07">=</span> 0<span style="color:#719e07">;</span>      <span style="color:#586e75">// Becomes 1 if any 1 bits are shifted off        while (n &gt;= MIN_MERGE) {              
</span><span style="color:#586e75"></span>    r <span style="color:#719e07">|=</span> <span style="color:#719e07">(</span>n <span style="color:#719e07">&amp;</span> 1<span style="color:#719e07">);</span>              
    n <span style="color:#719e07">&gt;&gt;=</span> 1<span style="color:#719e07">;</span>          
<span style="color:#719e07">}</span>          
<span style="color:#719e07">return</span> n <span style="color:#719e07">+</span> r<span style="color:#719e07">;</span>
</code></pre></div><p><code>gallopLeft()</code> 用 galloping search 找出最左 ≤ element 的位置，因為是 pass 整個 array 的 reference，所以會有 base / hint 去定位元素，看起來稍微複雜</p>
<p><code>mergeLo()、mergeHi()</code> 分別對應 (A+B)+C / A+(B+C) 兩種情況，邏輯類似， <code>outer</code> 段落就是在 one-pair-at-a-time mode，只有任一邊陣列連續大於 minGallop 才會切到 galloping mode；<br>
接著再 galloping mode，找到的元素必須位置大於 MIN_GALLOP，否則就會跳出 galloping mode，同時 minGallop會 +=2，也就是下次待在 one-pair-at-a-time mode 會更久。</p>
<p>透過 minGallop 與 MIN_GALLOP，確保 merge 在兩種模式中取得較佳的效率。</p>
<h3 id="bug">BUG</h3>
<p>如果再查 TimSort，你可能會找到這一篇文章</p>
<p><a href="http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/"><strong>Envisage: Engineering Virtualized Services</strong></a></p>
<p>主要在講 java 版的實作，可能會出現 OutMemeroyBound 的問題，主要是因為在 allocate Stack 的長度時，會有以下極端狀況導致 Stack 長度預設過短而記憶體不夠用</p>
<p>問題出在timsort本身的約束條件</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">1\. runLen[i-2] &gt; runLen[i-1] + runLen[i]  
2\. runLen[i-1] &gt; runLen[i]
</code></pre></div><p>在runLen為以下情況時，<code>120, 80, 25, 20, 30</code>，<code>25&lt;20+30</code>所以進行run[3]，run[4]合併，變為，<code>120, 80, 45, 30</code><br>
這時候由於 <code>80&gt;45+30, 45&gt;30</code> 條件滿足了，merge就終止了</p>
<p>但此時<code>120&lt;80+45</code>是不滿足約束條件的，但我們只對上層進行判斷<br>
如果（精心策劃）一些特殊數組造成大量這樣的情況，而在原始碼中 空間是這樣申請的</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int stackLen = (len &lt; 120 ? 5 :  
 len &lt; 1542 ? 10 :  
 len &lt; 119151 ? 19 : 40);  
runBase = new int[stackLen];  
runLen = new int[stackLen];
</code></pre></div><p>上面stackLen,是滿足上面提到的約束條件跟MIN_MERGE情況下去估計的最大可能數量，但剛也說了，只對上層進行判斷，會有例外狀況導致所需要的大小可能超出原本預想的，至於修復的方式是把檢查最後三個runLen變成檢查最後四個runLen</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#268bd2">private</span> <span style="color:#dc322f">void</span> <span style="color:#268bd2">newMergeCollapse</span><span style="color:#719e07">()</span> <span style="color:#719e07">{</span> 
 <span style="color:#719e07">while</span> <span style="color:#719e07">(</span>stackSize <span style="color:#719e07">&gt;</span> 1<span style="color:#719e07">)</span> <span style="color:#719e07">{</span>  
  <span style="color:#dc322f">int</span> n <span style="color:#719e07">=</span> stackSize <span style="color:#719e07">-</span> 2<span style="color:#719e07">;**</span>  
  <span style="color:#719e07">if</span> <span style="color:#719e07">(</span>   <span style="color:#719e07">(</span>n <span style="color:#719e07">&gt;=</span> 1 <span style="color:#719e07">&amp;&amp;</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">-</span>1<span style="color:#719e07">]</span> <span style="color:#719e07">&lt;=</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">]</span> <span style="color:#719e07">+</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">+</span>1<span style="color:#719e07">])</span> <span style="color:#719e07">||</span> <span style="color:#719e07">(</span>n <span style="color:#719e07">&gt;=</span> 2 <span style="color:#719e07">&amp;&amp;</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">-</span>2<span style="color:#719e07">]</span> <span style="color:#719e07">&lt;=</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">]</span> <span style="color:#719e07">+</span> runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">-</span>1<span style="color:#719e07">]))</span> <span style="color:#719e07">{</span>  
  <span style="color:#719e07">if</span> <span style="color:#719e07">(</span>runLen<span style="color:#719e07">[</span>n <span style="color:#719e07">-</span> 1<span style="color:#719e07">]</span> <span style="color:#719e07">&lt;</span> runLen<span style="color:#719e07">[</span>n <span style="color:#719e07">+</span> 1<span style="color:#719e07">])</span> n<span style="color:#719e07">--;</span>
  <span style="color:#719e07">}</span> <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> <span style="color:#719e07">(</span>runLen<span style="color:#719e07">[</span>n<span style="color:#719e07">]</span> <span style="color:#719e07">&gt;</span> runLen<span style="color:#719e07">[</span>n <span style="color:#719e07">+</span> 1<span style="color:#719e07">])</span> <span style="color:#719e07">{</span> 
    <span style="color:#719e07">break</span><span style="color:#719e07">;</span> <span style="color:#586e75">// Invariant is  established
</span><span style="color:#586e75"></span>  <span style="color:#719e07">}</span>
  mergeAt<span style="color:#719e07">(</span>n<span style="color:#719e07">);</span>  
 <span style="color:#719e07">}</span> 
<span style="color:#719e07">}</span>
</code></pre></div><p>以上 Bug 部分也是由強者公司同事 Frank 補充，有興趣者可以點進去看原文，原文包含說明了如何用工具與方法找出問題的，但因為還沒有到非常理解就不多做說明。</p>
<p>這 Bug 已經被修復，在 Python 的 Bug回報討論中，Tim Peter 提到其實現有的機器沒有足夠的 Memory 去產生這樣的問題，Java 版實作也是有一些改動才有辦法復現，不過最終基於邏輯的完整性，還是先修復了此問題，避免未來有問題。</p>
<h2 id="v8的實作">V8的實作</h2>
<p><a href="https://v8.dev/blog/array-sort#timsort"><strong>Getting things sorted in V8</strong></a></p>
<h2 id="前言">前言</h2>
<p>在評估排序演算法上，會考量<code>比對次數</code>跟<code>記憶體用量</code>，在動態語言包含 JS 中比對次數相對重要，因為在比對的時候會使用到用戶寫的程式碼</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> array <span style="color:#719e07">=</span> [<span style="color:#2aa198">4</span>, <span style="color:#2aa198">2</span>, <span style="color:#2aa198">5</span>, <span style="color:#2aa198">3</span>, <span style="color:#2aa198">1</span>];

<span style="color:#268bd2">function</span> compare(a, b) {  <span style="color:#586e75">// Arbitrary code goes here, e.g. `array.push(1);`. 
</span><span style="color:#586e75"></span>  <span style="color:#719e07">return</span> a <span style="color:#719e07">-</span> b;
}

<span style="color:#586e75">// A “typical” sort 
</span><span style="color:#586e75"></span>call.array.sort(compare);
</code></pre></div><p>比對函式回傳 <code>0 、1(或其他正值)、-1(或其他負值)</code>分別代表 <code>等於、大於、小於</code> ，在比對函式中用戶可能會有 Side-Effect 操作等</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> array <span style="color:#719e07">=</span> [<span style="color:#2aa198">4</span>, <span style="color:#2aa198">2</span>, <span style="color:#2aa198">5</span>, <span style="color:#2aa198">3</span>, <span style="color:#2aa198">1</span>];

array.push({  toString() {    <span style="color:#586e75">// Arbitrary code goes here, e.g. `array.push(1);`.    
</span><span style="color:#586e75"></span>  <span style="color:#719e07">return</span> <span style="color:#2aa198">&#39;42&#39;</span>;  
}});

<span style="color:#586e75">// Sort without a comparison 
</span><span style="color:#586e75"></span><span style="color:#268bd2">function</span>.array.sort();
</code></pre></div><p>預設的比對函式會先呼叫 <code>toString()</code>  轉成字串比對</p>
<p>接著把 Spec 先放在腦後，有一部分是 <code>Implementation-defined</code>  ，在一些 Spec 保留實作彈性的部分，工程師有機會去自由發揮，做出理想中用戶會希望看到的行為，但這部分各個 JS Engine 行為差異很大，例如說遇上了 <code>accessors(getter/setter)</code> 或<code>prototype-chain</code> ，強烈建議不要這樣寫程式，這裡僅作說明</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#268bd2">const</span> array <span style="color:#719e07">=</span> [<span style="color:#2aa198">0</span>, <span style="color:#2aa198">1</span>, <span style="color:#2aa198">2</span>];

<span style="color:#b58900">Object</span>.defineProperty(array, <span style="color:#2aa198">&#39;0&#39;</span>, {
    get() {
        console.log(<span style="color:#2aa198">&#39;get 0&#39;</span>);
        <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
    },
    set(v) {
        console.log(<span style="color:#2aa198">&#39;set 0&#39;</span>);
    }
});

<span style="color:#b58900">Object</span>.defineProperty(array, <span style="color:#2aa198">&#39;1&#39;</span>, {
    get() {
        console.log(<span style="color:#2aa198">&#39;get 1&#39;</span>);
        <span style="color:#719e07">return</span> <span style="color:#2aa198">1</span>;
    },
    set(v) {
        console.log(<span style="color:#2aa198">&#39;set 1&#39;</span>);
    }
});

array.sort();

<span style="color:#268bd2">const</span> object <span style="color:#719e07">=</span> {
    <span style="color:#2aa198">1</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;d1&#39;</span>,
    <span style="color:#2aa198">2</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;c1&#39;</span>,
    <span style="color:#2aa198">3</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;b1&#39;</span>,
    <span style="color:#2aa198">4</span><span style="color:#719e07">:</span> <span style="color:#cb4b16">undefined</span>,
    __proto__<span style="color:#719e07">:</span> {
        length<span style="color:#719e07">:</span> <span style="color:#2aa198">10000</span>,
        <span style="color:#2aa198">1</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;e2&#39;</span>,
        <span style="color:#2aa198">10</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;a2&#39;</span>,
        <span style="color:#2aa198">100</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;b2&#39;</span>,
        <span style="color:#2aa198">1000</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;c2&#39;</span>,
        <span style="color:#2aa198">2000</span><span style="color:#719e07">:</span> <span style="color:#cb4b16">undefined</span>,
        <span style="color:#2aa198">8000</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;d2&#39;</span>,
        <span style="color:#2aa198">12000</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;XX&#39;</span>,
        __proto__<span style="color:#719e07">:</span> {
            <span style="color:#2aa198">0</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;e3&#39;</span>,
            <span style="color:#2aa198">1</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;d3&#39;</span>,
            <span style="color:#2aa198">2</span><span style="color:#719e07">:</span> <span style="color:#2aa198">&#39;c3&#39;</span>,
            <span style="color:#2aa198">6</span><span style="color:#719e07">:</span> <span style="color:#cb4b16">undefined</span>,
        },
    }
};

<span style="color:#b58900">Array</span>.prototype.sort.call(object);
</code></pre></div><h2 id="v8-在排序前後的處理">V8 在排序前後的處理</h2>
<p>在 Spec中，將排序的元素分成三部分</p>
<ol>
<li>non-undefined value，這部分會套用比對函式決定排序</li>
<li>undefined value，放在排序的最後</li>
<li>holes，不存在的值</li>
</ol>
<p>V8 在實作上的步驟大概為</p>
<ol>
<li>找出 Array 或是 Object 的 <code>length</code></li>
<li>設變數 <code>numberOfUndefineds</code> 為 0</li>
<li>在範圍 <code>[0, length)</code> 中<br>
- 遇到 holes 不處理<br>
- 遇到 undefined 將 <code>numberOfUndefineds++</code>- 遇到 non-undefined value，放到暫存陣列上</li>
</ol>
<p>接著用 <code>TimSort</code> 對暫存陣列做排序，之後將暫存暫列寫回原陣列或物件中，並在後面補足 <code>numberOfUndefineds</code>  數量的 undefined，刪除剩餘的長度(移除 hole)，這樣就完成排序了。</p>
<h3 id="過去的實作">過去的實作</h3>
<p>過去 V8 是小陣列(length &lt; 10) 用 Insertion Sort 其餘採用 Quick Sort，而 Quick Sort 中分割的小陣列長度小於 10 也是用 Insertion Sort；<br>
因為 Quick Sort 是採用遞迴的方式，小陣列改用 Insertion Sort 效率較好。</p>
<p>Quick Sort 在選擇 pivot 的點很重要，選不好就會跑到最差情況 O(n²)，V8 採用兩種策略：<br>
1. 選擇子陣列中第一個、最後一個、第三個數的中位數<br>
2. 對於大的陣列，選擇被排序過數列的中位數</p>
<p>Quick Sort 優點在於是 In-Place 排序，但缺點有可能會落到 O(n²)。</p>
<p>現行就改成 TimSort 了。</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/javascript/"> javascript </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'yuanchieh';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-82837682-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




</body>
</html>
